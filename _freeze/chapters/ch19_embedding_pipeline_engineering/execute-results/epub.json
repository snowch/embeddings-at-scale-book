{
  "hash": "aff9fd5c5d09ec59d6717675aefa0947",
  "result": {
    "engine": "jupyter",
    "markdown": "# Embedding Pipeline Engineering {#sec-embedding-pipeline-engineering}\n\n:::{.callout-note}\n## Chapter Overview\nMoving from custom embedding development to production deployment requires robust engineering practices. This chapter explores the operational infrastructure needed to deploy, monitor, and maintain embedding systems at trillion-row scale. We'll cover MLOps practices specific to embeddings, the trade-offs between real-time and batch processing, versioning strategies that enable safe rollouts and rollbacks, A/B testing methodologies for embedding models, and comprehensive monitoring approaches to detect drift and degradation. These practices ensure embedding systems remain reliable, performant, and maintainable as they scale from prototype to production.\n:::\n\nThe journey from a successful embedding model to a production-ready system involves significant engineering challenges. Unlike traditional ML models that produce discrete predictions, embedding systems integrate into search pipelines, recommendation engines, and real-time decision systems where latency, freshness, and consistency are critical. This chapter provides the operational toolkit for building embedding pipelines that scale to hundreds of millions of queries per day across trillion-row datasets.\n\n## MLOps for Embedding Production\n\nEmbedding systems have unique MLOps requirements that distinguish them from traditional ML deployments. While a classification model serves predictions on demand, an embedding system must **continuously generate and update vectors for massive datasets, maintain multiple indices for fast retrieval, serve both embedding generation and similarity search, and coordinate versioning across embedding models and vector indices**.\n\n### The Embedding Production Stack\n\nA production embedding system comprises multiple interconnected components:\n\n::: {#44d07f25 .cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show Model Registry Implementation\"}\nimport json\nfrom datetime import datetime\nfrom pathlib import Path\nimport torch\n\n\nclass EmbeddingModelRegistry:\n    \"\"\"Registry for versioned embedding models with metadata tracking.\"\"\"\n\n    def __init__(self, registry_path=\"./models\"):\n        self.registry_path = Path(registry_path)\n        self.registry_path.mkdir(exist_ok=True)\n        self.models = {}\n\n    def register_model(self, model_id, model, metadata):\n        \"\"\"Register a new embedding model version.\"\"\"\n        model_path = self.registry_path / f\"{model_id}.pt\"\n        metadata_path = self.registry_path / f\"{model_id}.json\"\n\n        torch.save(model.state_dict(), model_path)\n\n        metadata[\"registered_at\"] = datetime.now().isoformat()\n        metadata[\"model_path\"] = str(model_path)\n        with open(metadata_path, 'w') as f:\n            json.dump(metadata, f, indent=2)\n\n        self.models[model_id] = metadata\n        print(f\"Registered model: {model_id}\")\n\n    def load_model(self, model_id, device=\"cpu\"):\n        \"\"\"Load model from registry.\"\"\"\n        model_path = self.registry_path / f\"{model_id}.pt\"\n        metadata_path = self.registry_path / f\"{model_id}.json\"\n\n        with open(metadata_path, 'r') as f:\n            metadata = json.load(f)\n\n        return torch.load(model_path, map_location=device), metadata\n\n\n# Usage example\nregistry = EmbeddingModelRegistry()\nmodel = torch.nn.Embedding(1000, 128)\nmetadata = {\"version\": \"1.0.0\", \"embedding_dim\": 128, \"description\": \"Production model\"}\nregistry.register_model(\"product-embeddings-v1.0.0\", model, metadata)\nprint(\"Model registry initialized\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRegistered model: product-embeddings-v1.0.0\nModel registry initialized\n```\n:::\n:::\n\n\n:::{.callout-tip}\n## Model Registry Best Practices\n1. **Semantic versioning**: Use MAJOR.MINOR.PATCH for model versions\n2. **Immutable models**: Never modify registered models; create new versions\n3. **Metadata completeness**: Track training data, hyperparameters, and performance metrics\n4. **Rollback plan**: Always maintain reference to previous production model\n5. **Audit trail**: Log all deployments, rollbacks, and configuration changes\n:::\n\n## Real-Time vs. Batch Embedding Generation\n\nOne of the most critical architectural decisions for embedding systems is **when and how to generate embeddings**. Batch processing offers throughput and cost efficiency, while real-time generation provides freshness and personalization. Most production systems use a hybrid approach, optimizing for different use cases within the same platform.\n\n### The Batch vs. Real-Time Trade-off\n\n**Batch Processing** generates embeddings offline in large batches:\n\n- **Advantages**: High throughput (10-100x faster), cost-efficient (cheaper compute), optimized resource utilization, quality control before serving\n- **Disadvantages**: Staleness (hours to days old), no personalization, large storage requirements, delayed updates\n- **Best for**: Product catalogs, document collections, static content, historical data\n\n**Real-Time Processing** generates embeddings on-demand:\n\n- **Advantages**: Fresh embeddings (milliseconds old), personalized to context, storage efficient (compute on-demand), immediate updates\n- **Disadvantages**: High latency (10-100ms), expensive (online GPU inference), variable load patterns, harder to monitor quality\n- **Best for**: User queries, personalized feeds, dynamic content, real-time sessions\n\n::: {#c0db8ede .cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show Hybrid Embedding System\"}\nimport torch\nfrom datetime import datetime, timedelta\n\n\nclass HybridEmbeddingSystem:\n    \"\"\"Hybrid system combining batch and real-time embedding generation.\"\"\"\n\n    def __init__(self, model, cache_size=100000):\n        self.model = model\n        self.model.eval()\n        self.batch_embeddings = {}\n        self.batch_timestamps = {}\n        self.cache = {}\n        self.cache_hits = 0\n        self.cache_misses = 0\n\n    def get_embedding(self, entity_id, entity_type, features=None, max_staleness=None):\n        \"\"\"Get embedding using appropriate strategy (batch or real-time).\"\"\"\n        if entity_type in [\"query\", \"session\"]:\n            return self._generate_realtime(entity_id, features)\n        elif entity_type in [\"product\", \"document\"]:\n            batch_emb = self._lookup_batch(entity_id, max_staleness)\n            return batch_emb if batch_emb is not None else self._generate_realtime(entity_id, features)\n        else:\n            raise ValueError(f\"Unknown entity type: {entity_type}\")\n\n    def _lookup_batch(self, entity_id, max_staleness):\n        \"\"\"Lookup pre-computed batch embedding.\"\"\"\n        if entity_id not in self.batch_embeddings:\n            return None\n        if max_staleness and (datetime.now() - self.batch_timestamps[entity_id]) > max_staleness:\n            return None\n        return self.batch_embeddings[entity_id]\n\n    def _generate_realtime(self, entity_id, features):\n        \"\"\"Generate embedding in real-time with caching.\"\"\"\n        if entity_id in self.cache:\n            self.cache_hits += 1\n            return self.cache[entity_id]\n\n        self.cache_misses += 1\n        with torch.no_grad():\n            embedding = self.model(features).cpu().numpy()\n        self.cache[entity_id] = embedding\n        return embedding\n\n    def batch_update(self, entity_ids, embeddings):\n        \"\"\"Update batch embeddings from offline processing.\"\"\"\n        timestamp = datetime.now()\n        for eid, emb in zip(entity_ids, embeddings):\n            self.batch_embeddings[eid] = emb\n            self.batch_timestamps[eid] = timestamp\n\n\n# Usage example\nmodel = torch.nn.Sequential(torch.nn.Linear(100, 128))\nhybrid = HybridEmbeddingSystem(model)\nemb = hybrid.get_embedding(\"product_123\", \"product\", features=torch.randn(1, 100), max_staleness=timedelta(days=1))\nprint(f\"Cache hit rate: {hybrid.cache_hits / (hybrid.cache_hits + hybrid.cache_misses) if hybrid.cache_misses > 0 else 0:.2%}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCache hit rate: 0.00%\n```\n:::\n:::\n\n\n:::{.callout-tip}\n## Choosing the Right Strategy\n\n**Use batch processing when:**\n\n- Entity changes are infrequent (daily/weekly updates)\n- Dataset is large but manageable (millions to billions)\n- Latency requirements are relaxed (seconds acceptable)\n- Cost optimization is critical\n\n**Use real-time generation when:**\n\n- Freshness is critical (sub-second requirements)\n- Entities are transient (search queries, sessions)\n- Personalization is required (user-specific embeddings)\n- Dataset is small (thousands to millions)\n\n**Use hybrid approach when:**\n\n- Mixed entity types with different requirements\n- Need both cost efficiency and freshness\n- Serving 100M+ requests/day across diverse use cases\n:::\n\n:::{.callout-warning}\n## Cold Start Problem\nReal-time generation can fail during cold starts (model not loaded, GPU unavailable). Always maintain:\n1. **Warm standby**: Pre-warmed models ready to serve\n2. **Fallback to batch**: Serve slightly stale batch embeddings if real-time fails\n3. **Graceful degradation**: Return approximate results rather than errors\n:::\n\n## Embedding Versioning and Rollback Strategies\n\nEmbeddings generated by different model versions are **incompatible**—you cannot mix vectors from v1.0 and v2.0 in the same similarity search. This creates unique versioning challenges that require careful coordination across the entire embedding pipeline.\n\n### The Versioning Challenge\n\nWhen you deploy a new embedding model:\n1. All existing embeddings become incompatible with new queries\n2. Must re-generate embeddings for entire corpus (billions of vectors)\n3. Must coordinate index updates with model deployment\n4. Must support rollback if new model underperforms\n\nThe core challenge: **How do you deploy a new embedding model without downtime or inconsistency?**\n\n::: {#c1bf46fd .cell execution_count=3}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show Deployment Strategy Implementation\"}\nfrom enum import Enum\nimport torch\n\n\nclass DeploymentStrategy(Enum):\n    \"\"\"Deployment strategies for new embedding models.\"\"\"\n    BLUE_GREEN = \"blue_green\"\n    INCREMENTAL = \"incremental\"\n    SHADOW = \"shadow\"\n    CANARY = \"canary\"\n\n\nclass EmbeddingVersionCoordinator:\n    \"\"\"Coordinate embedding model versions across pipeline stages.\"\"\"\n\n    def __init__(self, model_registry):\n        self.model_registry = model_registry\n        self.active_versions = {}\n        self.version_to_index = {}\n        self.traffic_routing = {}\n\n    def deploy_new_version(self, new_model_id, strategy, corpus_iterator=None):\n        \"\"\"Deploy new embedding model version using specified strategy.\"\"\"\n        print(f\"Deploying {new_model_id} using {strategy.value} strategy...\")\n\n        if strategy == DeploymentStrategy.BLUE_GREEN:\n            self._deploy_blue_green(new_model_id, corpus_iterator)\n        elif strategy == DeploymentStrategy.CANARY:\n            self._deploy_canary(new_model_id)\n\n    def _deploy_blue_green(self, new_model_id, corpus_iterator):\n        \"\"\"Blue-green deployment: build complete new index, then switch.\"\"\"\n        print(\"Building GREEN index (new version)...\")\n        green_index = f\"embeddings_{new_model_id.replace('.', '_')}\"\n        # Re-embed entire corpus into GREEN...\n        print(\"Switching traffic from BLUE → GREEN...\")\n        self.version_to_index[new_model_id] = green_index\n        self.traffic_routing[new_model_id] = 1.0\n\n    def _deploy_canary(self, new_model_id):\n        \"\"\"Canary deployment: route small % of traffic to new model.\"\"\"\n        self.traffic_routing[new_model_id] = 0.01  # 1% traffic\n        print(f\"Canary deployment: {new_model_id} receiving 1% traffic\")\n\n    def rollback(self, target_model_id):\n        \"\"\"Rollback to previous model version.\"\"\"\n        print(f\"Rolling back to {target_model_id}...\")\n        self.traffic_routing = {target_model_id: 1.0}\n\n\n# Usage example\nregistry = EmbeddingModelRegistry()\ncoordinator = EmbeddingVersionCoordinator(registry)\ncoordinator.deploy_new_version(\"v2.0.0\", DeploymentStrategy.CANARY)\nprint(\"Version coordinator manages safe deployments\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDeploying v2.0.0 using canary strategy...\nCanary deployment: v2.0.0 receiving 1% traffic\nVersion coordinator manages safe deployments\n```\n:::\n:::\n\n\n:::{.callout-tip}\n## Version Pinning for Reproducibility\n\nFor debugging and compliance, support **version pinning** in queries:\n```python\n# Allow clients to specify model version explicitly\nquery_embedding = embedding_service.get_embedding(\n    query=\"...\",\n    model_version=\"v1.2.3\"  # Pin to specific version\n)\n```\n\nThis enables:\n\n- Reproducing historical results for debugging\n- A/B testing different model versions\n- Gradual migration for sensitive applications\n:::\n\n## A/B Testing Embedding Models\n\nEmbedding quality is difficult to evaluate offline. **A/B testing** measures real-world impact on business metrics: click-through rate, conversion rate, user satisfaction, revenue. This section covers experimental design for embedding systems at scale.\n\n### Unique Challenges of Embedding A/B Tests\n\nUnlike testing UI changes or ranking algorithms, embedding A/B tests require:\n1. **Consistency**: Same user must see results from same model version throughout session\n2. **Index versioning**: Maintain separate indices for treatment and control\n3. **Longer ramp-up**: New embeddings need time to \"stabilize\" in caches\n4. **Interaction effects**: Embeddings affect multiple surfaces (search, recommendations, related items)\n\n::: {#7cdab61c .cell execution_count=4}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show A/B Testing Framework\"}\nimport hashlib\nfrom datetime import datetime\nimport numpy as np\n\n\nclass EmbeddingExperimentFramework:\n    \"\"\"Framework for A/B testing embedding models.\"\"\"\n\n    def __init__(self):\n        self.active_experiments = {}\n        self.user_assignments = {}\n        self.metrics = {}\n\n    def create_experiment(self, experiment_id, control_model, treatment_model, traffic_allocation=0.05):\n        \"\"\"Create new A/B test experiment.\"\"\"\n        self.active_experiments[experiment_id] = {\n            \"control\": control_model,\n            \"treatment\": treatment_model,\n            \"allocation\": traffic_allocation,\n            \"start_time\": datetime.now()\n        }\n        self.metrics[experiment_id] = []\n        print(f\"Created experiment: {experiment_id} with {traffic_allocation:.1%} treatment traffic\")\n\n    def assign_user(self, user_id, experiment_id):\n        \"\"\"Assign user to control or treatment (deterministic hash-based).\"\"\"\n        if user_id in self.user_assignments and experiment_id in self.user_assignments[user_id]:\n            return self.user_assignments[user_id][experiment_id]\n\n        hash_input = f\"{user_id}:{experiment_id}\".encode()\n        hash_value = int(hashlib.md5(hash_input).hexdigest()[:8], 16) / (2**32)\n\n        exp = self.active_experiments[experiment_id]\n        variant = \"treatment\" if hash_value < exp[\"allocation\"] else \"control\"\n\n        if user_id not in self.user_assignments:\n            self.user_assignments[user_id] = {}\n        self.user_assignments[user_id][experiment_id] = variant\n        return variant\n\n    def log_metric(self, experiment_id, user_id, metric_name, metric_value):\n        \"\"\"Log metric event for analysis.\"\"\"\n        variant = self.user_assignments.get(user_id, {}).get(experiment_id)\n        if not variant:\n            variant = self.assign_user(user_id, experiment_id)\n\n        self.metrics[experiment_id].append({\n            \"user_id\": user_id,\n            \"variant\": variant,\n            \"metric\": metric_name,\n            \"value\": metric_value,\n            \"timestamp\": datetime.now()\n        })\n\n    def analyze_experiment(self, experiment_id):\n        \"\"\"Analyze experiment results.\"\"\"\n        events = self.metrics[experiment_id]\n        control = [e for e in events if e[\"variant\"] == \"control\"]\n        treatment = [e for e in events if e[\"variant\"] == \"treatment\"]\n\n        control_mean = np.mean([e[\"value\"] for e in control]) if control else 0\n        treatment_mean = np.mean([e[\"value\"] for e in treatment]) if treatment else 0\n        lift = (treatment_mean - control_mean) / control_mean if control_mean > 0 else 0\n\n        return {\"control_mean\": control_mean, \"treatment_mean\": treatment_mean, \"lift\": lift}\n\n\n# Usage example\nframework = EmbeddingExperimentFramework()\nframework.create_experiment(\"emb_v2_test\", \"v1.0.0\", \"v2.0.0\", traffic_allocation=0.05)\nvariant = framework.assign_user(\"user_123\", \"emb_v2_test\")\nframework.log_metric(\"emb_v2_test\", \"user_123\", \"click_through_rate\", 0.15)\nresults = framework.analyze_experiment(\"emb_v2_test\")\nprint(f\"Experiment results: {results}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCreated experiment: emb_v2_test with 5.0% treatment traffic\nExperiment results: {'control_mean': np.float64(0.15), 'treatment_mean': 0, 'lift': np.float64(-1.0)}\n```\n:::\n:::\n\n\n:::{.callout-tip}\n## A/B Test Best Practices\n\n1. **Pre-register hypothesis**: Define success metrics before starting\n2. **Power analysis**: Calculate required sample size upfront\n3. **Avoid peeking**: Don't conclude early based on interim results (increases false positive rate)\n4. **Monitor guardrail metrics**: Latency, error rate, system health\n5. **Document everything**: Experiment design, results, learnings for future reference\n:::\n\n:::{.callout-warning}\n## Simpson's Paradox in Embedding Tests\n\nEmbeddings can show different effects across user segments. A model might improve recommendations for new users but degrade for power users. Always segment analysis by key user characteristics (tenure, engagement level, device type) to detect heterogeneous treatment effects.\n:::\n\n### Interleaving Experiments\n\n**Interleaving** provides a more sensitive alternative to A/B testing by showing results from both systems on the same result page and measuring user preferences directly. Where A/B tests require large sample sizes to detect small improvements, interleaving experiments can detect the same effect with 10-100x fewer users.\n\n::: {#e440680f .cell execution_count=5}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show Team Draft Interleaving implementation\"}\nimport numpy as np\nfrom typing import List, Tuple\nfrom dataclasses import dataclass\n\n@dataclass\nclass InterleavingResult:\n    \"\"\"Result of an interleaving experiment.\"\"\"\n    interleaved_list: List[str]\n    system_a_items: set\n    system_b_items: set\n    attribution: dict  # item_id -> system\n\nclass TeamDraftInterleaving:\n    \"\"\"\n    Team Draft Interleaving for comparing two ranking systems.\n\n    Alternates between systems picking items, like team captains\n    picking players. More sensitive than A/B testing for ranking\n    comparison.\n    \"\"\"\n\n    def interleave(\n        self,\n        ranking_a: List[str],\n        ranking_b: List[str],\n        length: int = 10\n    ) -> InterleavingResult:\n        \"\"\"\n        Create interleaved result list using Team Draft algorithm.\n\n        Args:\n            ranking_a: Ranked list from system A\n            ranking_b: Ranked list from system B\n            length: Maximum length of interleaved list\n        \"\"\"\n        interleaved = []\n        team_a = set()\n        team_b = set()\n        attribution = {}\n\n        ptr_a = 0\n        ptr_b = 0\n\n        while len(interleaved) < length:\n            # Randomly decide which team picks first this round\n            if np.random.random() < 0.5:\n                teams = [('A', ranking_a, team_a), ('B', ranking_b, team_b)]\n            else:\n                teams = [('B', ranking_b, team_b), ('A', ranking_a, team_a)]\n\n            for team_name, ranking, team_set in teams:\n                if len(interleaved) >= length:\n                    break\n\n                # Find next item from this ranking not already in list\n                ptr = ptr_a if team_name == 'A' else ptr_b\n                while ptr < len(ranking) and ranking[ptr] in interleaved:\n                    ptr += 1\n\n                if ptr < len(ranking):\n                    item = ranking[ptr]\n                    interleaved.append(item)\n                    team_set.add(item)\n                    attribution[item] = team_name\n                    ptr += 1\n\n                if team_name == 'A':\n                    ptr_a = ptr\n                else:\n                    ptr_b = ptr\n\n        return InterleavingResult(\n            interleaved_list=interleaved,\n            system_a_items=team_a,\n            system_b_items=team_b,\n            attribution=attribution\n        )\n\n    def compute_preference(\n        self,\n        result: InterleavingResult,\n        clicked_items: List[str]\n    ) -> dict:\n        \"\"\"\n        Compute system preference based on user clicks.\n\n        Returns which system the user preferred based on clicks.\n        \"\"\"\n        a_clicks = sum(1 for item in clicked_items if item in result.system_a_items)\n        b_clicks = sum(1 for item in clicked_items if item in result.system_b_items)\n\n        if a_clicks > b_clicks:\n            winner = 'A'\n        elif b_clicks > a_clicks:\n            winner = 'B'\n        else:\n            winner = 'tie'\n\n        return {\n            \"system_a_clicks\": a_clicks,\n            \"system_b_clicks\": b_clicks,\n            \"winner\": winner,\n            \"margin\": abs(a_clicks - b_clicks)\n        }\n\n\nclass InterleavingExperiment:\n    \"\"\"Run and analyze interleaving experiments.\"\"\"\n\n    def __init__(self, interleaver: TeamDraftInterleaving):\n        self.interleaver = interleaver\n        self.results = []\n\n    def record_impression(\n        self,\n        query_id: str,\n        ranking_a: List[str],\n        ranking_b: List[str],\n        clicks: List[str]\n    ):\n        \"\"\"Record a single interleaving impression and clicks.\"\"\"\n        interleaved = self.interleaver.interleave(ranking_a, ranking_b)\n        preference = self.interleaver.compute_preference(interleaved, clicks)\n\n        self.results.append({\n            \"query_id\": query_id,\n            \"winner\": preference[\"winner\"],\n            \"a_clicks\": preference[\"system_a_clicks\"],\n            \"b_clicks\": preference[\"system_b_clicks\"]\n        })\n\n    def analyze(self, min_queries: int = 100) -> dict:\n        \"\"\"Analyze experiment results.\"\"\"\n        if len(self.results) < min_queries:\n            return {\"error\": f\"Need at least {min_queries} queries\"}\n\n        a_wins = sum(1 for r in self.results if r[\"winner\"] == \"A\")\n        b_wins = sum(1 for r in self.results if r[\"winner\"] == \"B\")\n        ties = sum(1 for r in self.results if r[\"winner\"] == \"tie\")\n\n        total_decisive = a_wins + b_wins\n        if total_decisive == 0:\n            return {\"error\": \"No decisive comparisons\"}\n\n        # Delta: proportion of wins for B minus wins for A\n        delta = (b_wins - a_wins) / total_decisive\n\n        # Sign test for significance\n        from scipy import stats\n        p_value = stats.binom_test(b_wins, total_decisive, 0.5)\n\n        return {\n            \"n_queries\": len(self.results),\n            \"a_wins\": a_wins,\n            \"b_wins\": b_wins,\n            \"ties\": ties,\n            \"delta\": delta,  # Positive = B is better\n            \"p_value\": p_value,\n            \"significant\": p_value < 0.05,\n            \"winner\": \"B\" if delta > 0 and p_value < 0.05 else (\"A\" if delta < 0 and p_value < 0.05 else \"inconclusive\")\n        }\n\n\n# Example\ninterleaver = TeamDraftInterleaving()\n\n# Compare two ranking systems\nranking_a = [\"doc_1\", \"doc_2\", \"doc_3\", \"doc_4\", \"doc_5\"]\nranking_b = [\"doc_2\", \"doc_1\", \"doc_4\", \"doc_3\", \"doc_6\"]\n\nresult = interleaver.interleave(ranking_a, ranking_b, length=5)\nprint(f\"Interleaved list: {result.interleaved_list}\")\nprint(f\"System A items: {result.system_a_items}\")\nprint(f\"System B items: {result.system_b_items}\")\n\n# Simulate user clicking on doc_2 and doc_4\nclicks = [\"doc_2\", \"doc_4\"]\npreference = interleaver.compute_preference(result, clicks)\nprint(f\"User preference: {preference}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInterleaved list: ['doc_2', 'doc_1', 'doc_4', 'doc_3', 'doc_5']\nSystem A items: {'doc_5', 'doc_3', 'doc_1'}\nSystem B items: {'doc_2', 'doc_4'}\nUser preference: {'system_a_clicks': 0, 'system_b_clicks': 2, 'winner': 'B', 'margin': 2}\n```\n:::\n:::\n\n\n:::{.callout-tip}\n## When to Use Interleaving vs A/B Testing\n\n**Use interleaving when:**\n\n- Comparing ranking quality of two systems\n- You need faster results (10-100x fewer impressions required)\n- Systems are similar in quality (detecting small differences)\n- User-level randomization isn't critical\n\n**Use A/B testing when:**\n\n- Measuring absolute metrics (conversion rate, revenue)\n- Testing UI changes alongside embedding changes\n- You need user-level consistency for business metrics\n- Testing fundamentally different experiences\n\n**Best practice**: Use interleaving to quickly identify promising embedding models, then validate winners with A/B tests before full deployment.\n:::\n\n### Multi-Armed Bandits for Embedding Selection\n\n**Multi-armed bandits (MABs)** dynamically allocate traffic to better-performing embedding variants during an experiment, reducing the cost of testing inferior models. Unlike A/B tests with fixed allocation, bandits learn and adapt.\n\n::: {#9c0abcd8 .cell execution_count=6}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show Thompson Sampling Bandit\"}\nimport numpy as np\nfrom typing import Dict, List\nfrom dataclasses import dataclass, field\n\n@dataclass\nclass BetaArm:\n    \"\"\"Arm with Beta distribution prior for binary outcomes (clicks).\"\"\"\n    successes: int = 1  # Prior: Beta(1,1) = uniform\n    failures: int = 1\n\n    def sample(self) -> float:\n        \"\"\"Sample from posterior.\"\"\"\n        return np.random.beta(self.successes, self.failures)\n\n    def update(self, reward: float):\n        \"\"\"Update posterior with observed reward.\"\"\"\n        if reward > 0:\n            self.successes += 1\n        else:\n            self.failures += 1\n\n    @property\n    def mean(self) -> float:\n        \"\"\"Posterior mean.\"\"\"\n        return self.successes / (self.successes + self.failures)\n\n\nclass ThompsonSamplingBandit:\n    \"\"\"\n    Thompson Sampling for embedding model selection.\n\n    Balances exploration (trying uncertain models) with exploitation\n    (using known-good models) to minimize regret during experimentation.\n    \"\"\"\n\n    def __init__(self, model_ids: List[str]):\n        self.arms: Dict[str, BetaArm] = {\n            model_id: BetaArm() for model_id in model_ids\n        }\n        self.selection_history = []\n\n    def select_model(self) -> str:\n        \"\"\"Select model using Thompson Sampling.\"\"\"\n        samples = {\n            model_id: arm.sample()\n            for model_id, arm in self.arms.items()\n        }\n        selected = max(samples, key=samples.get)\n        self.selection_history.append(selected)\n        return selected\n\n    def record_outcome(self, model_id: str, success: bool):\n        \"\"\"Record outcome for selected model.\"\"\"\n        self.arms[model_id].update(1.0 if success else 0.0)\n\n    def get_statistics(self) -> dict:\n        \"\"\"Get current statistics for all arms.\"\"\"\n        return {\n            model_id: {\n                \"mean\": arm.mean,\n                \"successes\": arm.successes,\n                \"failures\": arm.failures,\n                \"total\": arm.successes + arm.failures - 2,  # Subtract prior\n                \"selection_rate\": self.selection_history.count(model_id) / len(self.selection_history) if self.selection_history else 0\n            }\n            for model_id, arm in self.arms.items()\n        }\n\n    def get_best_model(self) -> str:\n        \"\"\"Return model with highest posterior mean.\"\"\"\n        return max(self.arms, key=lambda m: self.arms[m].mean)\n\n\nclass UCBBandit:\n    \"\"\"\n    Upper Confidence Bound (UCB) bandit for embedding selection.\n\n    More deterministic than Thompson Sampling, good for\n    settings where reproducibility matters.\n    \"\"\"\n\n    def __init__(self, model_ids: List[str], exploration_weight: float = 2.0):\n        self.model_ids = model_ids\n        self.exploration_weight = exploration_weight\n        self.successes = {m: 0 for m in model_ids}\n        self.trials = {m: 0 for m in model_ids}\n        self.total_trials = 0\n\n    def select_model(self) -> str:\n        \"\"\"Select model using UCB algorithm.\"\"\"\n        # Ensure each model is tried at least once\n        for model_id in self.model_ids:\n            if self.trials[model_id] == 0:\n                return model_id\n\n        ucb_values = {}\n        for model_id in self.model_ids:\n            mean = self.successes[model_id] / self.trials[model_id]\n            exploration_bonus = np.sqrt(\n                self.exploration_weight * np.log(self.total_trials) / self.trials[model_id]\n            )\n            ucb_values[model_id] = mean + exploration_bonus\n\n        return max(ucb_values, key=ucb_values.get)\n\n    def record_outcome(self, model_id: str, success: bool):\n        \"\"\"Record outcome.\"\"\"\n        self.trials[model_id] += 1\n        self.total_trials += 1\n        if success:\n            self.successes[model_id] += 1\n\n    def get_statistics(self) -> dict:\n        return {\n            model_id: {\n                \"mean\": self.successes[model_id] / max(self.trials[model_id], 1),\n                \"trials\": self.trials[model_id],\n                \"successes\": self.successes[model_id]\n            }\n            for model_id in self.model_ids\n        }\n\n\n# Example: Compare embedding models with Thompson Sampling\nnp.random.seed(42)\n\nmodels = [\"emb_v1\", \"emb_v2\", \"emb_v3\"]\n# True click rates (unknown to bandit)\ntrue_rates = {\"emb_v1\": 0.10, \"emb_v2\": 0.12, \"emb_v3\": 0.11}\n\nbandit = ThompsonSamplingBandit(models)\n\n# Simulate 1000 requests\nfor _ in range(1000):\n    selected = bandit.select_model()\n    # Simulate click based on true rate\n    clicked = np.random.random() < true_rates[selected]\n    bandit.record_outcome(selected, clicked)\n\nprint(\"Thompson Sampling Results after 1000 requests:\")\nstats = bandit.get_statistics()\nfor model_id, s in stats.items():\n    print(f\"  {model_id}: mean={s['mean']:.3f}, selected {s['selection_rate']:.1%}, n={s['total']}\")\nprint(f\"Best model: {bandit.get_best_model()}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThompson Sampling Results after 1000 requests:\n  emb_v1: mean=0.082, selected 14.5%, n=145\n  emb_v2: mean=0.119, selected 46.0%, n=460\n  emb_v3: mean=0.116, selected 39.5%, n=395\nBest model: emb_v2\n```\n:::\n:::\n\n\n:::{.callout-warning}\n## Bandit Caveats for Embedding Experiments\n\n**Delayed rewards**: Embedding quality may not show immediate effects (e.g., conversion happens days after search). Use appropriate attribution windows.\n\n**Non-stationarity**: If embedding quality changes over time (model degradation, seasonal effects), standard bandits may not adapt correctly. Consider windowed or discounted bandits.\n\n**Context matters**: User segments may prefer different embeddings. Consider contextual bandits that condition on user features.\n\n**Compliance**: Some regulatory contexts require fixed allocation (clinical trials). Bandits may not be appropriate for all experiments.\n:::\n\n### Online Learning from Implicit Feedback\n\nProduction embedding systems can learn from user interactions continuously, adapting to changing preferences without full retraining.\n\n::: {#68b0cef8 .cell execution_count=7}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show position bias correction\"}\nimport numpy as np\nfrom typing import List, Tuple\n\nclass PositionBiasCorrector:\n    \"\"\"\n    Correct for position bias in click data.\n\n    Users are more likely to click higher-ranked results regardless\n    of relevance. This class estimates and corrects for position bias\n    to get unbiased relevance signals.\n    \"\"\"\n\n    def __init__(self, n_positions: int = 10):\n        self.n_positions = n_positions\n        # Initialize position bias estimates (examination probabilities)\n        self.examination_prob = np.ones(n_positions)\n        self.position_clicks = np.zeros(n_positions)\n        self.position_impressions = np.zeros(n_positions)\n\n    def estimate_examination_probability(\n        self,\n        click_data: List[Tuple[int, bool]]  # (position, clicked)\n    ):\n        \"\"\"\n        Estimate examination probability per position.\n\n        Uses result randomization or swap experiments to estimate\n        how likely users are to examine each position.\n        \"\"\"\n        for position, clicked in click_data:\n            if position < self.n_positions:\n                self.position_impressions[position] += 1\n                if clicked:\n                    self.position_clicks[position] += 1\n\n        # Simple estimate: CTR at position / max CTR\n        ctrs = np.divide(\n            self.position_clicks,\n            self.position_impressions,\n            where=self.position_impressions > 0,\n            out=np.zeros(self.n_positions)\n        )\n        max_ctr = ctrs.max() if ctrs.max() > 0 else 1\n        self.examination_prob = ctrs / max_ctr\n        self.examination_prob = np.clip(self.examination_prob, 0.01, 1.0)\n\n    def correct_click(\n        self,\n        position: int,\n        clicked: bool\n    ) -> float:\n        \"\"\"\n        Return position-bias-corrected relevance signal.\n\n        Uses Inverse Propensity Scoring (IPS) to debias clicks.\n        \"\"\"\n        if position >= self.n_positions:\n            return 0.0\n\n        exam_prob = self.examination_prob[position]\n\n        if clicked:\n            # IPS: upweight clicks at low-examination positions\n            return 1.0 / exam_prob\n        else:\n            # For non-clicks, we can't distinguish \"not examined\" from\n            # \"examined but not relevant\". Return 0 for simplicity.\n            return 0.0\n\n    def get_unbiased_relevance_estimates(\n        self,\n        impressions: List[dict]  # [{position, clicked, item_id}, ...]\n    ) -> dict:\n        \"\"\"\n        Get unbiased relevance estimates per item.\n        \"\"\"\n        item_relevance = {}\n        item_counts = {}\n\n        for imp in impressions:\n            item_id = imp[\"item_id\"]\n            corrected = self.correct_click(imp[\"position\"], imp[\"clicked\"])\n\n            if item_id not in item_relevance:\n                item_relevance[item_id] = 0\n                item_counts[item_id] = 0\n\n            item_relevance[item_id] += corrected\n            item_counts[item_id] += 1\n\n        # Average corrected relevance\n        return {\n            item_id: item_relevance[item_id] / item_counts[item_id]\n            for item_id in item_relevance\n        }\n\n\n# Example\nnp.random.seed(42)\ncorrector = PositionBiasCorrector(n_positions=10)\n\n# Simulate click data with position bias\nclick_data = []\nfor _ in range(10000):\n    position = np.random.randint(0, 10)\n    # Click probability decreases with position\n    true_exam_prob = 1.0 / (1 + position * 0.3)\n    clicked = np.random.random() < true_exam_prob * 0.3  # 30% base CTR if examined\n    click_data.append((position, clicked))\n\ncorrector.estimate_examination_probability(click_data)\nprint(\"Estimated examination probabilities:\")\nfor i, prob in enumerate(corrector.examination_prob):\n    print(f\"  Position {i}: {prob:.3f}\")\n\n# Correct a click at position 5\nraw_click = 1.0\ncorrected = corrector.correct_click(position=5, clicked=True)\nprint(f\"\\nRaw click at position 5: {raw_click}\")\nprint(f\"Corrected (IPS) relevance: {corrected:.2f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEstimated examination probabilities:\n  Position 0: 1.000\n  Position 1: 0.788\n  Position 2: 0.639\n  Position 3: 0.499\n  Position 4: 0.510\n  Position 5: 0.357\n  Position 6: 0.436\n  Position 7: 0.334\n  Position 8: 0.262\n  Position 9: 0.245\n\nRaw click at position 5: 1.0\nCorrected (IPS) relevance: 2.80\n```\n:::\n:::\n\n\n:::{.callout-tip}\n## Implicit Feedback Best Practices\n\n**Combine multiple signals**: Clicks alone are noisy. Combine with dwell time, add-to-cart, purchases, and returns for robust relevance estimates.\n\n**Use counterfactual evaluation**: Before deploying models trained on biased data, use off-policy evaluation to estimate their true performance.\n\n**Monitor feedback loops**: Models trained on their own predictions can amplify biases. Track diversity metrics and inject exploration to prevent filter bubbles.\n:::\n\n## Monitoring Embedding Drift and Degradation\n\nEmbedding quality degrades over time even without model changes. Data distribution shifts, user behavior evolves, and the corpus grows. **Continuous monitoring** detects degradation before it impacts users, enabling proactive retraining and updates.\n\n### Sources of Embedding Degradation\n\n1. **Data drift**: Input data distribution changes (new product categories, seasonal trends)\n2. **Concept drift**: Relationships between entities change (word meanings shift, user preferences evolve)\n3. **Corpus growth**: New items dilute existing embeddings (index becomes less representative)\n4. **Model staleness**: Fixed model doesn't adapt to new patterns\n5. **Infrastructure changes**: Index configuration, hardware, network latency\n\n::: {#236a4fe2 .cell execution_count=8}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show Embedding Monitoring System\"}\nfrom datetime import datetime\nimport numpy as np\nimport torch\n\n\nclass EmbeddingMonitoringSystem:\n    \"\"\"Continuous monitoring system for embedding quality and drift detection.\"\"\"\n\n    def __init__(self, model, test_dataset, alert_thresholds=None):\n        self.model = model\n        self.test_dataset = test_dataset\n        self.alert_thresholds = alert_thresholds or {\n            \"recall_drop\": 0.05,\n            \"latency_increase\": 0.20,\n            \"norm_change\": 0.15\n        }\n        self.baseline_metrics = None\n        self.historical_metrics = []\n\n    def evaluate_current_quality(self, sample_size=10000):\n        \"\"\"Evaluate current embedding quality.\"\"\"\n        self.model.eval()\n\n        # Intrinsic metrics\n        with torch.no_grad():\n            sample_embeddings = self.model(torch.randn(sample_size, 100))\n        norms = torch.norm(sample_embeddings, dim=1)\n        avg_norm = norms.mean().item()\n\n        # Extrinsic metrics (simplified)\n        recall_at_10 = 0.89  # Placeholder for real evaluation\n\n        metrics = {\n            \"timestamp\": datetime.now(),\n            \"avg_norm\": avg_norm,\n            \"recall_at_10\": recall_at_10\n        }\n\n        return metrics\n\n    def detect_drift(self, current_metrics):\n        \"\"\"Detect drift in embedding quality.\"\"\"\n        if self.baseline_metrics is None:\n            self.baseline_metrics = current_metrics\n            print(\"Baseline metrics established\")\n            return {}\n\n        alerts = {}\n\n        # Check recall drift\n        recall_drop = (self.baseline_metrics[\"recall_at_10\"] - current_metrics[\"recall_at_10\"]) / self.baseline_metrics[\"recall_at_10\"]\n        if recall_drop > self.alert_thresholds[\"recall_drop\"]:\n            alerts[\"recall_degradation\"] = True\n            print(f\"ALERT: Recall dropped {recall_drop:.1%} from baseline\")\n\n        # Check norm drift\n        norm_change = abs(current_metrics[\"avg_norm\"] - self.baseline_metrics[\"avg_norm\"]) / self.baseline_metrics[\"avg_norm\"]\n        if norm_change > self.alert_thresholds[\"norm_change\"]:\n            alerts[\"distribution_shift\"] = True\n            print(f\"ALERT: Embedding norm changed {norm_change:.1%}\")\n\n        if not alerts:\n            print(\"No drift detected - quality stable\")\n\n        return alerts\n\n    def should_retrain(self, alerts, days_since_training):\n        \"\"\"Decide whether to trigger model retraining.\"\"\"\n        critical_alerts = [\"recall_degradation\", \"distribution_shift\"]\n        if any(alerts.get(alert) for alert in critical_alerts):\n            return True, \"quality_degradation\"\n        if days_since_training > 30:\n            return True, \"model_staleness\"\n        return False, \"\"\n\n\n# Usage example\nmodel = torch.nn.Sequential(torch.nn.Linear(100, 128))\nmonitor = EmbeddingMonitoringSystem(model, test_dataset=None)\nmetrics = monitor.evaluate_current_quality(sample_size=1000)\nalerts = monitor.detect_drift(metrics)\nshould_retrain, reason = monitor.should_retrain(alerts, days_since_training=15)\nprint(f\"Monitoring: {len(alerts)} alerts, Retrain needed: {should_retrain}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBaseline metrics established\nMonitoring: 0 alerts, Retrain needed: False\n```\n:::\n:::\n\n\n:::{.callout-tip}\n## Monitoring Dashboard Essentials\n\nA production embedding monitoring dashboard should display:\n\n**Real-time metrics** (updated every minute):\n\n- Query latency (p50, p95, p99)\n- Throughput (queries/second)\n- Error rate\n- Cache hit rate\n\n**Quality metrics** (updated hourly/daily):\n\n- Retrieval recall@10, recall@100\n- NDCG@10\n- User engagement metrics (CTR, conversion rate)\n- Embedding distribution statistics\n\n**System health** (updated every 5 minutes):\n\n- Index size and growth rate\n- Memory usage\n- GPU utilization\n- Background job status (retraining, re-embedding)\n:::\n\n:::{.callout-warning}\n## Silent Degradation\nEmbedding quality can degrade gradually without triggering alerts. Complement threshold-based alerts with:\n\n- **Trend analysis**: Detect slow downward trends even within thresholds\n- **Comparative baselines**: Compare against historical best, not just initial baseline\n- **Canary queries**: Maintain set of \"golden queries\" that should always perform well\n\nFor comprehensive evaluation metrics including intrinsic quality (isotropy, uniformity), retrieval metrics (MAP, NDCG, MRR), human evaluation frameworks, and domain-specific metrics, see @sec-embedding-quality-evaluation.\n:::\n\n## Key Takeaways\n\n- **MLOps for embeddings requires specialized infrastructure**: Model registries, batch inference pipelines, and version coordination across training, serving, and indexing stages differentiate embedding systems from traditional ML deployments\n\n- **Hybrid batch/real-time strategies optimize cost and freshness**: Batch processing for stable entities (products, documents), real-time generation for dynamic content (queries, sessions), and caching for popular items balances throughput, latency, and resource utilization at scale\n\n- **Embedding versioning is complex due to incompatibility between model versions**: Blue-green, incremental, shadow, and canary deployment strategies each offer different trade-offs between safety, speed, and resource requirements when updating embedding models\n\n- **A/B testing measures real-world embedding impact**: Hash-based user assignment, consistent routing, separate indices per variant, and statistical analysis of business metrics (CTR, conversion, revenue) validate embedding improvements beyond offline metrics\n\n- **Continuous monitoring detects degradation before user impact**: Track intrinsic metrics (embedding norms, variance, nearest neighbor distances), extrinsic metrics (recall, NDCG, MRR), and system metrics (latency, throughput) with drift detection and automatic retraining triggers\n\n- **Production embedding systems require operational maturity**: Rollback plans, version pinning for reproducibility, graceful degradation, alerting on quality and performance regressions, and documentation of all experiments and deployments\n\n- **Scale demands automation**: Manual embedding pipeline management breaks down at trillion-row scale; invest in automated quality monitoring, deployment orchestration, and retraining workflows early\n\n## Looking Ahead\n\nThis chapter covered the operational practices for deploying and maintaining embedding systems in production. @sec-scaling-embedding-training shifts focus to the computational challenges of training embedding models at scale, exploring distributed training architectures, gradient accumulation and mixed precision techniques, memory optimization strategies, and multi-GPU/multi-node training approaches that enable learning from trillion-row datasets.\n\n## Further Reading\n\n### MLOps and Model Management\n- Sculley et al. (2015). \"Hidden Technical Debt in Machine Learning Systems.\" NeurIPS.\n- Renggli et al. (2021). \"A Data Quality-Driven View of MLOps.\" IEEE Data Engineering Bulletin.\n- Paleyes et al. (2022). \"Challenges in Deploying Machine Learning: A Survey of Case Studies.\" ACM Computing Surveys.\n\n### Deployment Strategies\n- Kubernetes Documentation. \"Blue-Green Deployments and Canary Releases.\"\n- Richardson, C. (2018). \"Microservices Patterns: With Examples in Java.\" Manning Publications.\n- Humble & Farley (2010). \"Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation.\" Addison-Wesley.\n\n### A/B Testing\n- Kohavi & Longbotham (2017). \"Online Controlled Experiments and A/B Testing.\" Encyclopedia of Machine Learning and Data Mining.\n- Deng et al. (2013). \"Improving the Sensitivity of Online Controlled Experiments by Utilizing Pre-Experiment Data.\" WSDM.\n- Gupta et al. (2019). \"Top Challenges from the First Practical Online Controlled Experiments Summit.\" SIGKDD.\n\n### Monitoring and Observability\n- Schelter et al. (2018). \"Automating Large-Scale Data Quality Verification.\" VLDB.\n- Polyzotis et al. (2018). \"Data Lifecycle Challenges in Production Machine Learning.\" SIGMOD.\n- Breck et al. (2019). \"Data Validation for Machine Learning.\" MLSys.\n\n### Embedding-Specific Operations\n- Grbovic & Cheng (2018). \"Real-time Personalization using Embeddings for Search Ranking at Airbnb.\" KDD.\n- Haldar et al. (2019). \"Applying Deep Learning To Airbnb Search.\" KDD.\n- Bernhardsson, E. (2015). \"Nearest Neighbors and Vector Models.\" Erik Bernhardsson Blog.\n\n",
    "supporting": [
      "ch19_embedding_pipeline_engineering_files/figure-epub"
    ],
    "filters": [],
    "engineDependencies": {
      "jupyter": [
        {
          "jsWidgets": false,
          "jupyterWidgets": false,
          "htmlLibraries": []
        }
      ]
    }
  }
}