{
  "hash": "d2828aa5b0703225c64ed9680db10f22",
  "result": {
    "engine": "jupyter",
    "markdown": "# Security and Privacy {#sec-security-privacy}\n\n:::{.callout-note}\n## Chapter Overview\nSecurity and privacy—from protecting sensitive embeddings to enabling privacy-preserving queries to ensuring regulatory compliance—determine whether embedding systems can operate on confidential data while maintaining user trust and legal compliance. This chapter covers security and privacy fundamentals: embedding encryption and secure computation protecting sensitive vectors through homomorphic encryption and secure multi-party computation that enable encrypted similarity search with <10% overhead, privacy-preserving similarity search using locality-sensitive hashing and differential privacy that prevent query vector and database content leakage while maintaining 90%+ utility, differential privacy for embeddings providing formal privacy guarantees through controlled noise injection that bound information leakage to ε≤1.0 while preserving semantic relationships, access control and audit trails implementing fine-grained permissions and comprehensive logging that ensure only authorized queries access sensitive embeddings, and GDPR and data sovereignty compliance through data residency controls, right-to-deletion workflows, and audit capabilities that satisfy regulatory requirements across jurisdictions. These techniques transform embedding systems from security-problematic prototypes to enterprise-grade platforms that protect confidential data, preserve user privacy, and satisfy regulatory mandates—enabling deployment on healthcare records, financial transactions, and personal data while maintaining 80-95% of unencrypted system performance.\n:::\n\nAfter optimizing performance (@sec-performance-optimization), **security and privacy become paramount for production deployment**. Embedding systems process sensitive data—customer behavior, proprietary documents, medical records, financial transactions—and generate vectors that encode private information. Traditional database security (encryption at rest, access control, audit logs) protects storage but fails during computation: similarity search requires accessing unencrypted embeddings, query vectors reveal search intent, and nearest neighbors leak database content. **Security-aware embedding systems** use cryptographic techniques (homomorphic encryption, secure enclaves, differential privacy) to protect data during computation, privacy-preserving algorithms (LSH with noise, federated learning) to prevent information leakage, and comprehensive access controls with auditing to ensure compliance—enabling deployment on confidential data while maintaining 80-95% of unencrypted performance and satisfying GDPR, HIPAA, SOC2, and other regulatory frameworks.\n\n## Embedding Encryption and Secure Computation\n\nEmbeddings encode semantic information from source data—a customer behavior embedding reveals purchasing patterns, a document embedding exposes content themes, a medical record embedding encodes diagnosis information. **Encryption and secure computation** protect embeddings throughout their lifecycle while enabling similarity search, achieving cryptographic security guarantees (IND-CPA, semantic security) with practical performance (<10× overhead for most operations) through homomorphic encryption (compute on encrypted vectors), secure enclaves (trusted execution environments), and secure multi-party computation (distributed computation without revealing inputs).\n\n### The Embedding Security Challenge\n\nEmbedding systems face unique security requirements:\n\n- **At-rest encryption**: Embeddings stored encrypted, but traditional encryption prevents similarity search\n- **In-transit protection**: Query vectors and results transmitted securely without revealing content\n- **Computation security**: Similarity search on encrypted vectors without decryption\n- **Query privacy**: Search queries don't reveal query content to database operator\n- **Result privacy**: Returned neighbors don't leak database content beyond necessary\n- **Performance requirements**: <10× overhead for encrypted operations, <100ms query latency\n- **Key management**: Secure key distribution, rotation, revocation at scale\n- **Multi-tenant isolation**: Prevent cross-tenant data leakage in shared systems\n\n**Security approach**: Layer multiple techniques—encryption at rest protects stored vectors (AES-256), encryption in transit protects network communication (TLS 1.3), homomorphic encryption or secure enclaves enable computation on encrypted data, differential privacy bounds information leakage from query results, and access controls with audit trails ensure only authorized queries proceed.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show secure embedding computation architecture\"}\nfrom dataclasses import dataclass\nfrom typing import Optional, List\nfrom enum import Enum\nimport torch\nimport torch.nn as nn\n\nclass SecurityLevel(Enum):\n    PLAINTEXT = \"plaintext\"\n    ENCRYPTED_AT_REST = \"encrypted_at_rest\"\n    HOMOMORPHIC = \"homomorphic\"\n    SECURE_ENCLAVE = \"secure_enclave\"\n\n@dataclass\nclass SecurityConfig:\n    level: SecurityLevel = SecurityLevel.ENCRYPTED_AT_REST\n    key_size_bits: int = 256\n    enable_audit: bool = True\n\nclass SecureEmbeddingStore(nn.Module):\n    \"\"\"Secure embedding storage with encryption support.\"\"\"\n    def __init__(self, config: SecurityConfig, embedding_dim: int = 768):\n        super().__init__()\n        self.config = config\n        self.encryption_key_encoder = nn.Linear(config.key_size_bits // 8, embedding_dim)\n        self.similarity_head = nn.CosineSimilarity(dim=-1)\n\n    def secure_similarity(self, query: torch.Tensor, stored: torch.Tensor,\n                         mask: Optional[torch.Tensor] = None) -> torch.Tensor:\n        scores = self.similarity_head(query.unsqueeze(1), stored)\n        if mask is not None:\n            scores = scores.masked_fill(~mask, float('-inf'))\n        return scores\n\n# Usage example\nconfig = SecurityConfig(level=SecurityLevel.HOMOMORPHIC)\nstore = SecureEmbeddingStore(config)\nquery = torch.randn(1, 768)\nstored = torch.randn(100, 768)\nscores = store.secure_similarity(query, stored)\nprint(f\"Security level: {config.level.value}, Similarity scores: {scores.shape}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSecurity level: homomorphic, Similarity scores: torch.Size([1, 100])\n```\n:::\n:::\n\n\n:::{.callout-warning}\n## Production Considerations\n\n**Homomorphic Encryption**:\n\n- Use established libraries: TenSEAL, Microsoft SEAL, OpenFHE\n- CKKS provides approximate arithmetic, suitable for embeddings\n- Performance: 10-100× slower than plaintext operations\n- Memory: Ciphertexts are 10-50× larger than plaintexts\n- Noise management: Track noise budget, refresh when needed\n\n**Intel SGX**:\n\n- Limited enclave memory: 128MB (SGX1) to 256GB (SGX2+)\n- Page faults expensive: Load data in batches\n- Side channels: Use constant-time operations, ORAM\n- Attestation: Verify enclave authenticity before sending data\n- Cloud availability: Azure DCv2/DCv3, GCP N2D\n\n**Key Management**:\n\n- Separate key hierarchy: Master → encryption → sealing keys\n- Rotation: Support key rotation without re-encrypting all data\n- Multi-tenant: Per-tenant keys for isolation\n- Recovery: Secure key backup and recovery procedures\n\n**Performance Optimization**:\n\n- Batching: Encrypt/process multiple vectors at once\n- Caching: Cache decrypted vectors (if security model allows)\n- Hybrid: Use SGX for hot paths, CKKS for cold storage\n- Hardware acceleration: Use GPUs for CKKS operations\n:::\n\n:::{.callout-tip}\n## Security-Performance Trade-offs\n\n**High Security, Lower Performance** (10-100× overhead):\n\n- Full homomorphic encryption (FHE)\n- All operations on encrypted data\n- Use: Healthcare, financial regulatory data\n- Cost: $10-50 per million queries\n\n**Balanced** (2-5× overhead):\n\n- Intel SGX or AMD SEV\n- Computation in secure enclave\n- Use: Enterprise multi-tenant systems\n- Cost: $1-5 per million queries\n\n**Privacy-Utility Trade-off** (<2× overhead):\n\n- Differential privacy with plaintext computation\n- Add calibrated noise to queries/results\n- Use: Public-facing services, analytics\n- Cost: $0.10-1 per million queries\n\nChoose based on:\n\n- Threat model: Who are you protecting against?\n- Regulatory requirements: HIPAA, PCI-DSS, GDPR?\n- Performance budget: What latency/throughput needed?\n- Infrastructure: SGX availability, key management capability?\n:::\n## Privacy-Preserving Similarity Search\n\nSimilarity search reveals information—query vectors expose search intent, returned neighbors leak database content, access patterns reveal correlations. **Privacy-preserving similarity search** enables queries without revealing query content to the database operator or database content to the querier beyond the k results, using locality-sensitive hashing with noise injection, secure multi-party computation, and differential privacy to balance utility (95%+ recall) with formal privacy guarantees (ε≤1.0 differential privacy, query unlinkability, result indistinguishability).\n\n### The Privacy-Leakage Challenge\n\nStandard similarity search leaks information:\n\n- **Query leakage**: Database sees query vector, learns user intent\n- **Result leakage**: User sees neighbors, learns about database content\n- **Access pattern leakage**: Repeated queries reveal correlations\n- **Membership leakage**: Can determine if specific embedding in database\n- **Model inversion**: Reconstruct training data from embeddings\n- **Attribute inference**: Infer sensitive attributes from similar embeddings\n- **Linkage attacks**: Connect embeddings across databases\n\n**Privacy approach**: Private information retrieval (PIR) enables queries without revealing query to server, oblivious RAM (ORAM) hides access patterns, secure multi-party computation distributes trust, differential privacy adds calibrated noise to bound information leakage, and federated learning keeps data distributed.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show privacy-preserving similarity search\"}\nfrom dataclasses import dataclass\nfrom typing import Optional, Tuple\nfrom enum import Enum\nimport torch\nimport torch.nn as nn\n\nclass PrivacyMethod(Enum):\n    NONE = \"none\"\n    DIFFERENTIAL_PRIVACY = \"differential_privacy\"\n    LSH_NOISE = \"lsh_noise\"\n    SECURE_MPC = \"secure_mpc\"\n\n@dataclass\nclass PrivacyConfig:\n    method: PrivacyMethod = PrivacyMethod.DIFFERENTIAL_PRIVACY\n    epsilon: float = 1.0\n    delta: float = 1e-5\n    noise_multiplier: float = 1.0\n\nclass PrivateSearcher(nn.Module):\n    \"\"\"Privacy-preserving similarity search with DP guarantees.\"\"\"\n    def __init__(self, config: PrivacyConfig, embedding_dim: int = 768):\n        super().__init__()\n        self.config = config\n        self.lsh_projections = nn.Parameter(torch.randn(embedding_dim, 128))\n\n    def add_noise(self, tensor: torch.Tensor) -> torch.Tensor:\n        sensitivity = 2.0  # L2 sensitivity for normalized embeddings\n        noise_scale = sensitivity * self.config.noise_multiplier / self.config.epsilon\n        noise = torch.randn_like(tensor) * noise_scale\n        return tensor + noise\n\n    def private_search(self, query: torch.Tensor, database: torch.Tensor,\n                       k: int = 10) -> Tuple[torch.Tensor, torch.Tensor]:\n        noisy_query = self.add_noise(query)\n        scores = torch.matmul(noisy_query, database.T)\n        noisy_scores = self.add_noise(scores)\n        top_values, top_indices = noisy_scores.topk(k, dim=-1)\n        return top_indices, top_values\n\n# Usage example\nconfig = PrivacyConfig(epsilon=1.0, noise_multiplier=1.1)\nsearcher = PrivateSearcher(config)\nquery = torch.randn(1, 768)\ndatabase = torch.randn(1000, 768)\nindices, scores = searcher.private_search(query, database, k=10)\nprint(f\"Privacy: ε={config.epsilon}, Top-{indices.shape[1]} results retrieved\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPrivacy: ε=1.0, Top-10 results retrieved\n```\n:::\n:::\n\n\n:::{.callout-warning}\n## Privacy-Utility Trade-offs\n\n**Differential Privacy Parameter Selection**:\n\n- **ε = 0.1**: Very strong privacy, 30-50% utility loss\n  - Use: Healthcare records, sensitive personal data\n- **ε = 1.0**: Balanced, 10-20% utility loss\n  - Use: Enterprise data, financial records (recommended)\n- **ε = 10.0**: Weak privacy, <5% utility loss\n  - Use: Public datasets, aggregate statistics\n\n**LSH Privacy Enhancement**:\n\n- Standard LSH: No privacy, reveals bucket membership\n- DP-LSH: ε-differential privacy per query\n- Overhead: 2-3× latency, 10-20% recall loss\n- Composition: Privacy budget degrades with queries\n\n**MPC Performance**:\n\n- 2-party: 5-10× overhead vs plaintext\n- 3+ parties: 10-50× overhead\n- Communication: O(n) per similarity computation\n- Best for: Federated learning, cross-silo queries\n:::\n\n:::{.callout-tip}\n## Practical Privacy Deployment\n\n**Start with Hybrid Approach**:\n\n1. Public-facing API: Differential privacy (ε=1.0)\n2. Internal trusted use: Minimal privacy overhead\n3. Cross-tenant: SGX enclaves + DP\n4. External federation: Secure MPC\n\n**Privacy Budget Management**:\n\n- Set daily/monthly privacy budget per user\n- Track cumulative ε across queries\n- Throttle or reject when budget exhausted\n- Use privacy accounting (e.g., Rényi DP, zCDP)\n\n**Optimize for Common Case**:\n\n- Cache popular queries (public results)\n- Use coarser privacy for exploratory queries\n- Apply stronger privacy for sensitive final queries\n- Batch similar queries for composition benefits\n\n**Monitor Privacy-Utility**:\n\n- Track recall at different ε levels\n- A/B test privacy parameters\n- Measure user satisfaction vs privacy cost\n- Adjust based on regulatory requirements\n:::\n## Differential Privacy for Embeddings\n\nEmbedding models trained on sensitive data encode private information—training on medical records produces embeddings that leak diagnoses, training on private messages exposes conversation patterns. **Differential privacy for embeddings** provides formal mathematical guarantees that embeddings reveal bounded information about any individual training example, using noise injection during training (DP-SGD), output perturbation after training, and privacy accounting to track cumulative privacy loss—achieving ε≤1.0 privacy while maintaining 85-95% of non-private model utility.\n\n### The Training Privacy Challenge\n\nEmbedding model training faces privacy risks:\n\n- **Membership inference**: Determine if specific example was in training data\n- **Attribute inference**: Infer sensitive attributes from embeddings\n- **Model inversion**: Reconstruct training examples from model\n- **Embedding leakage**: Similar embeddings reveal similar training data\n- **Gradient leakage**: Training gradients expose training examples\n- **Fine-tuning risk**: Fine-tuning on private data leaks information\n- **Deployment exposure**: Serving embeddings leaks training distribution\n\n**Differential privacy approach**: Add calibrated noise during training (DP-SGD) to prevent any single training example from significantly affecting model, bound privacy loss through privacy accounting (ε,δ), clip gradients to limit per-example influence, use private aggregation for federated learning, and apply output perturbation for additional privacy layer.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show differential privacy training architecture\"}\nfrom dataclasses import dataclass\nfrom typing import Optional\nimport torch\nimport torch.nn as nn\n\n@dataclass\nclass DPTrainingConfig:\n    epsilon: float = 1.0\n    delta: float = 1e-5\n    max_grad_norm: float = 1.0\n    noise_multiplier: float = 1.1\n\nclass DPEmbeddingTrainer(nn.Module):\n    \"\"\"Differentially private embedding model training.\"\"\"\n    def __init__(self, config: DPTrainingConfig, embedding_dim: int = 768):\n        super().__init__()\n        self.config = config\n        self.encoder = nn.Sequential(\n            nn.Linear(embedding_dim, 512),\n            nn.ReLU(),\n            nn.Linear(512, embedding_dim)\n        )\n\n    def clip_gradients(self, grads: torch.Tensor) -> torch.Tensor:\n        grad_norm = grads.norm(2, dim=-1, keepdim=True)\n        clip_factor = torch.clamp(self.config.max_grad_norm / (grad_norm + 1e-8), max=1.0)\n        return grads * clip_factor\n\n    def add_noise_to_gradients(self, grads: torch.Tensor) -> torch.Tensor:\n        noise_scale = self.config.max_grad_norm * self.config.noise_multiplier\n        noise = torch.randn_like(grads) * noise_scale\n        return grads + noise\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        return self.encoder(x)\n\n# Usage example\nconfig = DPTrainingConfig(epsilon=1.0, max_grad_norm=1.0)\ntrainer = DPEmbeddingTrainer(config)\nembeddings = torch.randn(32, 768)\noutput = trainer(embeddings)\nprint(f\"DP Training: ε={config.epsilon}, δ={config.delta}\")\nprint(f\"Input: {embeddings.shape} -> Output: {output.shape}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDP Training: ε=1.0, δ=1e-05\nInput: torch.Size([32, 768]) -> Output: torch.Size([32, 768])\n```\n:::\n:::\n\n\n:::{.callout-warning}\n## Differential Privacy Trade-offs\n\n**Privacy-Utility Frontier**:\n\n- **ε = 0.1**: Very strong privacy, 40-60% utility loss\n  - Use: Extremely sensitive data (genetic, health)\n- **ε = 1.0**: Strong privacy, 10-20% utility loss\n  - Use: Personal data (recommended for GDPR)\n- **ε = 10.0**: Weak privacy, <5% utility loss\n  - Use: Aggregate statistics, exploratory analysis\n\n**DP-SGD Challenges**:\n\n- **Training time**: 2-5× longer due to per-example gradients\n- **Memory**: 1.5-2× higher for gradient storage\n- **Hyperparameters**: Requires careful tuning (clipping, noise)\n- **Convergence**: May require more epochs\n\n**Production Recommendations**:\n\n- Start with ε=3.0, tune down based on requirements\n- Use adaptive clipping (percentile-based)\n- Implement privacy accounting with Opacus or TF Privacy\n- Monitor utility metrics throughout training\n- Consider PATE for better utility when applicable\n:::\n\n:::{.callout-tip}\n## Practical DP Implementation\n\n**Use Established Libraries**:\n\n- **Opacus** (PyTorch): Production-ready DP-SGD\n  - `pip install opacus`\n  - Handles per-example gradients automatically\n  - Advanced privacy accounting (RDP, GDP)\n\n- **TensorFlow Privacy**: TF ecosystem DP\n  - `pip install tensorflow-privacy`\n  - DP optimizers, privacy analysis\n  - Supports Keras models\n\n**Privacy Accounting**:\n\n- Use Rényi DP (RDP) for tighter bounds\n- Track privacy loss per epoch\n- Set privacy budget alarm (warn at 80%)\n- Report final (ε,δ) with model release\n\n**Hyperparameter Tuning**:\n\n- Grid search over clipping threshold (0.1-5.0)\n- Adjust noise multiplier based on target ε\n- Use learning rate warm-up\n- Increase batch size (helps privacy)\n\n**Validation**:\n\n- Measure utility on holdout set\n- Compare with non-private baseline\n- Check for privacy leakage via membership inference\n- Document privacy parameters in model card\n:::\n## Access Control and Audit Trails\n\nEmbedding systems serve multiple users with varying permissions—data scientists need read access for analysis, application servers need query access for recommendations, administrators need full access for management, and auditors need query logs for compliance. **Access control and audit trails** implement fine-grained permissions (who can query which embeddings with what filters), comprehensive logging (all queries, results, and access attempts), immutable audit trails for compliance, and real-time monitoring for anomaly detection—enabling secure multi-tenant deployments, regulatory compliance (SOC2, HIPAA, PCI-DSS), and forensic investigation of security incidents.\n\n### The Access Control Challenge\n\nProduction embedding systems face access requirements:\n\n- **Multi-tenancy**: Isolate tenant data, prevent cross-tenant leakage\n- **Role-based access**: Different permissions for roles (admin, analyst, service)\n- **Attribute-based access**: Filter queries based on data attributes (region, classification)\n- **Query constraints**: Limit query rate, result size, complexity\n- **Data sovereignty**: Enforce geographic restrictions\n- **Temporal access**: Time-limited credentials, temporary shares\n- **Audit compliance**: Immutable logs for regulatory requirements\n- **Real-time monitoring**: Detect suspicious access patterns\n\n**Access control approach**: Implement role-based access control (RBAC) with attribute-based extensions (ABAC), use signed tokens (JWT) with embedded permissions, enforce row-level security filtering based on user attributes, implement rate limiting and quota management, maintain comprehensive audit logs with query details and results, use append-only storage for tamper-proof auditing, and monitor access patterns for anomaly detection.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show access control and audit architecture\"}\nfrom dataclasses import dataclass, field\nfrom typing import Optional, List, Set\nfrom enum import Enum\nfrom datetime import datetime\nimport torch\nimport torch.nn as nn\n\nclass Permission(Enum):\n    READ = \"read\"\n    WRITE = \"write\"\n    DELETE = \"delete\"\n    ADMIN = \"admin\"\n\n@dataclass\nclass AccessPolicy:\n    user_id: str\n    permissions: Set[Permission] = field(default_factory=set)\n    allowed_namespaces: List[str] = field(default_factory=list)\n    rate_limit_qps: float = 100.0\n\n@dataclass\nclass AuditEntry:\n    timestamp: datetime\n    user_id: str\n    action: str\n    resource: str\n    success: bool\n\nclass AccessController(nn.Module):\n    \"\"\"Fine-grained access control with audit logging.\"\"\"\n    def __init__(self, embedding_dim: int = 768):\n        super().__init__()\n        self.user_encoder = nn.Linear(64, embedding_dim)\n        self.resource_encoder = nn.Linear(embedding_dim, 64)\n        self.permission_head = nn.Linear(64 + 64, len(Permission))\n\n    def check_access(self, user_features: torch.Tensor,\n                     resource_embedding: torch.Tensor) -> torch.Tensor:\n        user_enc = self.user_encoder(user_features)\n        res_enc = self.resource_encoder(resource_embedding)\n        combined = torch.cat([user_enc[:, :64], res_enc], dim=-1)\n        permission_logits = self.permission_head(combined)\n        return torch.sigmoid(permission_logits)\n\n# Usage example\ncontroller = AccessController()\nuser_features = torch.randn(1, 64)\nresource = torch.randn(1, 768)\npermissions = controller.check_access(user_features, resource)\nprint(f\"Permission probabilities: {permissions.shape}\")\nprint(f\"Permissions: {[p.value for p in Permission]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPermission probabilities: torch.Size([1, 4])\nPermissions: ['read', 'write', 'delete', 'admin']\n```\n:::\n:::\n\n\n:::{.callout-warning}\n## Production Access Control\n\n**Authentication Methods**:\n\n- **API Keys**: Simple, suitable for service-to-service\n  - Generate cryptographically random keys (32+ bytes)\n  - Store hashed, never plaintext\n  - Support rotation without downtime\n\n- **OAuth 2.0 / JWT**: Standard for user authentication\n  - Verify token signature (RS256, ES256)\n  - Check expiration (exp claim)\n  - Validate issuer and audience\n  - Use short-lived tokens (15-60 minutes)\n\n- **Mutual TLS**: Strongest for service authentication\n  - Client certificate verification\n  - Certificate pinning\n  - Automatic rotation\n\n**Authorization Best Practices**:\n\n- Start with least privilege\n- Use role hierarchy (inherit permissions)\n- Implement deny policies (override allows)\n- Cache authorization decisions (with TTL)\n- Audit failed authorization attempts\n\n**Audit Log Requirements**:\n\n- Immutable storage (append-only)\n- Tamper-proof (cryptographic hashes, blockchain)\n- Long retention (7 years for HIPAA)\n- Searchable and exportable\n- Automated alerting on suspicious patterns\n:::\n\n:::{.callout-tip}\n## Compliance Considerations\n\n**SOC 2 Requirements**:\n\n- Logical access controls\n- Authentication and authorization\n- Audit logging and monitoring\n- Incident response procedures\n- Annual penetration testing\n\n**HIPAA Requirements**:\n\n- Unique user identification\n- Automatic logoff (session timeout)\n- Encryption of ePHI\n- Audit controls (access logs)\n- Integrity controls (tamper detection)\n\n**PCI-DSS Requirements**:\n\n- Two-factor authentication for admin\n- Unique ID per user\n- Audit trail for all access to cardholder data\n- Log retention (1 year online, 3 years archived)\n- Quarterly log review\n\n**GDPR Considerations**:\n\n- Log personal data access\n- Support data subject access requests\n- Implement right to be forgotten\n- Document data processing activities\n- Report breaches within 72 hours\n:::\n## GDPR and Data Sovereignty Compliance\n\nEmbedding systems processing personal data must comply with data protection regulations—GDPR requires data minimization, purpose limitation, user consent, right to access, right to deletion, and data portability. **GDPR and data sovereignty compliance** implements technical measures for regulatory compliance: data residency controls ensuring embeddings stay in required jurisdictions, consent management tracking lawful basis for processing, right-to-deletion workflows removing user data from embeddings and training sets, data portability enabling export in machine-readable formats, privacy impact assessments documenting risks and mitigations, and breach notification procedures detecting and reporting incidents—enabling legal deployment across EU, California (CCPA), Brazil (LGPD), and other jurisdictions with comprehensive data protection laws.\n\n### The Regulatory Compliance Challenge\n\nEmbedding systems face regulatory requirements:\n\n- **Data residency**: Keep EU citizens' data in EU datacenters\n- **Lawful basis**: Document consent, contract, or legitimate interest\n- **Purpose limitation**: Use data only for stated purposes\n- **Data minimization**: Collect and retain minimum necessary data\n- **Right to access**: Provide copy of user's data on request\n- **Right to deletion**: Remove user data from all systems\n- **Right to portability**: Export data in machine-readable format\n- **Breach notification**: Detect and report incidents within 72 hours\n- **Data protection by design**: Build privacy into system architecture\n- **Privacy impact assessment**: Document risks for high-risk processing\n\n**Compliance approach**: Implement geographic data partitioning for residency, maintain consent records and privacy policies, build deletion workflows that remove data from embeddings and indexes, provide data export APIs for portability, conduct privacy impact assessments before deployment, implement breach detection and notification procedures, and document all data processing activities.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show GDPR compliance architecture\"}\nfrom dataclasses import dataclass, field\nfrom typing import Optional, List, Dict\nfrom enum import Enum\nfrom datetime import datetime\nimport torch\nimport torch.nn as nn\n\nclass DataRegion(Enum):\n    EU = \"eu\"\n    US = \"us\"\n    APAC = \"apac\"\n\nclass ConsentType(Enum):\n    PROCESSING = \"processing\"\n    ANALYTICS = \"analytics\"\n    MARKETING = \"marketing\"\n\n@dataclass\nclass GDPRCompliance:\n    data_subject_id: str\n    region: DataRegion\n    consents: Dict[ConsentType, bool] = field(default_factory=dict)\n    deletion_requested: bool = False\n    deletion_completed: Optional[datetime] = None\n\nclass DataResidencyManager(nn.Module):\n    \"\"\"Manages data residency and GDPR compliance.\"\"\"\n    def __init__(self, n_regions: int = 3, embedding_dim: int = 768):\n        super().__init__()\n        self.region_embeddings = nn.Parameter(torch.randn(n_regions, 32))\n        self.residency_classifier = nn.Linear(embedding_dim + 32, n_regions)\n\n    def determine_residency(self, user_embedding: torch.Tensor,\n                           region_hint: torch.Tensor) -> torch.Tensor:\n        combined = torch.cat([user_embedding, region_hint], dim=-1)\n        region_logits = self.residency_classifier(combined)\n        return torch.softmax(region_logits, dim=-1)\n\n# Usage example\nmanager = DataResidencyManager()\nuser_emb = torch.randn(1, 768)\nregion_hint = torch.randn(1, 32)\nresidency_probs = manager.determine_residency(user_emb, region_hint)\nprint(f\"Data residency probabilities: {residency_probs.shape}\")\nprint(f\"Regions: {[r.value for r in DataRegion]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nData residency probabilities: torch.Size([1, 3])\nRegions: ['eu', 'us', 'apac']\n```\n:::\n:::\n\n\n:::{.callout-warning}\n## GDPR Compliance Requirements\n\n**Must-Have Technical Measures**:\n\n- **Data residency**: EU data must stay in EU\n- **Consent management**: Track legal basis, allow withdrawal\n- **Deletion workflows**: Complete removal within reasonable time\n- **Export capability**: Machine-readable format (JSON, CSV, XML)\n- **Breach detection**: Identify incidents within hours\n- **Audit trails**: Complete processing history\n\n**Common Compliance Pitfalls**:\n\n- Forgetting backups: Deletion must include backups\n- Training data: Removing from training sets is hard\n- Third parties: Ensure processors are GDPR-compliant\n- Consent fatigue: Don't ask for consent too frequently\n- Dark patterns: Don't make withdrawal harder than consent\n- Incomplete deletion: Check logs, analytics, caches\n\n**Penalties**:\n\n- Up to €20M or 4% of global annual revenue\n- Fines for: No legal basis, inadequate security, no breach notification\n- Reputation damage, loss of customer trust\n:::\n\n:::{.callout-tip}\n## Practical GDPR Implementation\n\n**Data Residency**:\n\n- Use cloud providers with regional guarantees\n  - AWS: Specific regions (eu-west-1, eu-central-1)\n  - GCP: Regional resources\n  - Azure: Geography-specific data residency\n- Implement geo-fencing at application level\n- Regular audits of data location\n\n**Deletion Implementation** (note: deletion from embedding systems is an unsolved challenge at scale):\n\n- Asynchronous processing (don't block user)\n- Multi-stage: Active data → Archives → Backups\n- Track deletion status, notify user on completion\n- Consider \"soft delete\" with delayed hard delete\n- **Unsolved challenges**: Removing individual records from trained models is technically difficult—models may have \"memorized\" patterns from deleted data; removing from production vector indices requires rebuilding or tombstoning; complete forensic deletion from all replicas may be infeasible\n\n**Consent Management**:\n\n- Granular consent (separate purposes)\n- Easy withdrawal (one-click)\n- Consent refresh (annual reminder)\n- Log all consent changes with timestamps\n\n**Breach Response Plan**:\n\n1. Detection: Automated anomaly detection\n2. Assessment: Severity, scope, affected users (1 hour)\n3. Containment: Stop the breach, secure systems (2 hours)\n4. Notification: Supervisory authority (72 hours)\n5. User notification: High-risk breaches (no undue delay)\n6. Documentation: Complete incident report\n\n**Documentation**:\n\n- Privacy policy (user-facing)\n- Data processing activities (Article 30)\n- Privacy impact assessment (high-risk processing)\n- Data protection by design documentation\n- Vendor data processing agreements\n:::\n\n## Key Takeaways\n\n- **Embedding encryption enables computation on sensitive data with practical overhead**: Homomorphic encryption (CKKS) provides cryptographic security for similarity search with 10-100× performance overhead suitable for high-security scenarios, Intel SGX secure enclaves offer 2-5× overhead enabling production deployment on confidential data, hybrid approaches combine techniques adapting to deployment constraints, and key management infrastructure ensures secure key distribution and rotation—enabling healthcare, financial, and government deployments that were previously impossible\n\n- **Privacy-preserving similarity search prevents information leakage while maintaining utility**: Differentially private LSH adds calibrated noise to hash functions achieving ε≤1.0 privacy with 10-20% recall loss, secure multi-party computation distributes queries across data silos preventing single-party data exposure with 5-50× overhead, private information retrieval enables queries without revealing query content using homomorphic encryption, and access pattern hiding through oblivious RAM prevents correlation attacks—enabling public-facing APIs and cross-organizational collaboration\n\n- **Differential privacy for embeddings provides formal guarantees for training and serving**: DP-SGD adds Gaussian noise during training achieving (ε,δ)-differential privacy with 10-20% utility loss at ε=1.0, gradient clipping bounds per-example influence preventing training data memorization, privacy accounting tracks cumulative privacy loss across queries and model releases, PATE enables student model training without direct privacy cost when public data available, and privacy-utility trade-offs require careful hyperparameter tuning balancing regulatory compliance with model performance\n\n- **Access control and audit trails ensure secure multi-tenant deployment and compliance**: Role-based access control (RBAC) with attribute-based extensions (ABAC) enables fine-grained permissions, row-level security filtering prevents cross-tenant data leakage, rate limiting and quota management prevent abuse and ensure fair resource allocation, comprehensive audit logging with immutable storage satisfies regulatory requirements, and real-time anomaly detection identifies suspicious access patterns before damage occurs—achieving SOC2, HIPAA, and PCI-DSS compliance\n\n- **GDPR and data sovereignty compliance enables legal deployment across jurisdictions**: Geographic data partitioning ensures EU data stays in EU datacenters satisfying residency requirements, consent management tracks lawful basis for processing with granular purpose-specific consent and easy withdrawal, right-to-deletion workflows remove user data from embeddings and training sets within required timeframes, data portability exports provide machine-readable data packages, breach notification procedures detect and report incidents within 72 hours, and comprehensive documentation satisfies privacy impact assessment and Article 30 requirements\n\n- **Security and privacy are system-wide requirements not afterthoughts**: No single technique provides complete protection—production systems layer encryption (at rest and in transit), secure computation (SGX/CKKS), differential privacy (formal guarantees), access control (authentication and authorization), and compliance workflows (GDPR/CCPA)—each addressing different threat models and regulatory requirements while maintaining 80-95% of unencrypted system performance\n\n- **Regulatory landscape evolves requiring adaptable compliance architecture**: GDPR (EU), CCPA (California), LGPD (Brazil), PIPEDA (Canada), and PDPA (Singapore/Thailand) have overlapping but distinct requirements, new regulations emerge regularly (e.g., AI Act, state privacy laws), enforcement increases with multi-million dollar fines, and technical measures must adapt without complete system redesign—necessitating modular compliance architecture with configurable policies, regular legal review, and proactive monitoring of regulatory developments\n\n## Looking Ahead\n\n@sec-monitoring-observability establishes comprehensive monitoring and observability practices: embedding quality metrics that detect model degradation and concept drift, performance monitoring dashboards tracking latency and throughput across deployment, alerting on embedding drift when semantic space shifts require model retraining, cost tracking and optimization ensuring efficient resource utilization, and user experience analytics measuring how embedding quality impacts business metrics.\n\n## Further Reading\n\n### Homomorphic Encryption and Secure Computation\n- Cheon, Jung Hee, et al. (2017). \"Homomorphic Encryption for Arithmetic of Approximate Numbers.\" Advances in Cryptology – ASIACRYPT.\n- Smart, Nigel P., and Frederik Vercauteren (2014). \"Fully Homomorphic SIMD Operations.\" Designs, Codes and Cryptography.\n- Costan, Victor, and Srinivas Devadas (2016). \"Intel SGX Explained.\" IACR Cryptology ePrint Archive.\n- Hunt, Tyler, et al. (2018). \"Ryoan: A Distributed Sandbox for Untrusted Computation on Secret Data.\" ACM Transactions on Computer Systems.\n\n### Privacy-Preserving Machine Learning\n- Dwork, Cynthia, and Aaron Roth (2014). \"The Algorithmic Foundations of Differential Privacy.\" Foundations and Trends in Theoretical Computer Science.\n- Abadi, Martin, et al. (2016). \"Deep Learning with Differential Privacy.\" ACM Conference on Computer and Communications Security.\n- Papernot, Nicolas, et al. (2017). \"Scalable Private Learning with PATE.\" International Conference on Learning Representations.\n- McMahan, Brendan, et al. (2017). \"Communication-Efficient Learning of Deep Networks from Decentralized Data.\" Artificial Intelligence and Statistics.\n\n### Differential Privacy\n- Dwork, Cynthia, Frank McSherry, Kobbi Nissim, and Adam Smith (2006). \"Calibrating Noise to Sensitivity in Private Data Analysis.\" Theory of Cryptography Conference.\n- Mironov, Ilya (2017). \"Rényi Differential Privacy.\" IEEE Computer Security Foundations Symposium.\n- Bun, Mark, and Thomas Steinke (2016). \"Concentrated Differential Privacy: Simplifications, Extensions, and Lower Bounds.\" Theory of Cryptography Conference.\n- Kairouz, Peter, Sewoong Oh, and Pramod Viswanath (2015). \"The Composition Theorem for Differential Privacy.\" International Conference on Machine Learning.\n\n### Access Control and Auditing\n- Sandhu, Ravi S., et al. (1996). \"Role-Based Access Control Models.\" Computer.\n- Hu, Vincent C., et al. (2014). \"Guide to Attribute Based Access Control (ABAC) Definition and Considerations.\" NIST Special Publication 800-162.\n- Schneier, Bruce (2015). \"Data and Goliath: The Hidden Battles to Collect Your Data and Control Your World.\" W. W. Norton & Company.\n- Kelley, Patrick Gage, et al. (2009). \"A Conundrum of Permissions: Installing Applications on an Android Smartphone.\" International Conference on Financial Cryptography and Data Security.\n\n### GDPR and Data Protection\n- Voigt, Paul, and Axel von dem Bussche (2017). \"The EU General Data Protection Regulation (GDPR): A Practical Guide.\" Springer.\n- European Union Agency for Cybersecurity (2020). \"Guidelines on Data Protection Impact Assessment (DPIA).\" Article 29 Working Party.\n- Information Commissioner's Office (2018). \"Guide to the General Data Protection Regulation (GDPR).\" ICO.\n- Solove, Daniel J., and Paul M. Schwartz (2021). \"Information Privacy Law.\" Wolters Kluwer.\n\n### Privacy in Practice\n- Nissim, Kobbi, et al. (2017). \"Bridging the Gap Between Computer Science and Legal Approaches to Privacy.\" Harvard Journal of Law & Technology.\n- Veale, Michael, Reuben Binns, and Lilian Edwards (2018). \"Algorithms that Remember: Model Inversion Attacks and Data Protection Law.\" Philosophical Transactions of the Royal Society A.\n- Wachter, Sandra, Brent Mittelstadt, and Chris Russell (2021). \"Why Fairness Cannot Be Automated: Bridging the Gap Between EU Non-Discrimination Law and AI.\" Computer Law & Security Review.\n- Narayanan, Arvind, and Vitaly Shmatikov (2008). \"Robust De-anonymization of Large Sparse Datasets.\" IEEE Symposium on Security and Privacy.\n\n### Security Best Practices\n- OWASP (2021). \"OWASP Top Ten Project.\" Open Web Application Security Project.\n- Cloud Security Alliance (2020). \"Security Guidance for Critical Areas of Focus in Cloud Computing.\" CSA.\n- NIST (2018). \"Framework for Improving Critical Infrastructure Cybersecurity.\" National Institute of Standards and Technology.\n- ISO/IEC (2013). \"ISO/IEC 27001:2013 Information Security Management.\" International Organization for Standardization.\n\n",
    "supporting": [
      "ch37_security_privacy_files/figure-pdf"
    ],
    "filters": []
  }
}