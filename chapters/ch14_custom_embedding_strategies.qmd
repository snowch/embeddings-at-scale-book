# Beyond Pre-trained: Custom Embedding Strategies {#sec-custom-embedding-strategies}

:::{.callout-note}
## Chapter Overview
This chapter bridges strategic planning and implementation by answering a critical question: when should you build custom embeddings versus fine-tuning existing models? We explore domain-specific requirements, multi-objective design, dimensionality optimization, and cost-performance trade-offs that determine success at scale.
:::

## When to Build Custom Embeddings vs. Fine-Tune

The decision to build custom embeddings from scratch versus fine-tuning pre-trained models is one of the most consequential choices in your embedding strategy. Make the wrong choice and you'll either waste months building unnecessary infrastructure or deploy suboptimal models that never reach competitive performance.

### The Custom vs. Fine-Tune Spectrum

Most discussions frame this as a binary choice. In reality, it's a spectrum with five distinct approaches:

:::{.callout-note}
The following cost and quality estimates are rough guidelines based on typical projects. Actual results vary significantly based on domain, data quality, team expertise, and specific requirements.
:::

**Level 0: Use Pre-trained, Frozen**

- **Description**: Use off-the-shelf embeddings (OpenAI, Sentence-BERT) without modification
- **Effort**: Hours
- **Cost**: $0-$1K/month
- **Quality**: 60-70% of optimal for your domain
- **Best for**: Proof-of-concepts, generic use cases, rapid prototyping

**Level 1: Prompt Engineering**

- **Description**: Optimize prompts for pre-trained models to better capture domain nuances
- **Effort**: Days to weeks
- **Cost**: $1K-$5K/month
- **Quality**: 70-80% of optimal
- **Best for**: Specific queries, instruction-based models, low-budget projects

**Level 2: Fine-Tune Last Layers**

- **Description**: Fine-tune final layers of pre-trained model on your domain data
- **Effort**: Weeks
- **Cost**: $5K-$25K one-time + ongoing inference
- **Quality**: 80-90% of optimal
- **Best for**: Domain adaptation with limited data (10K-100K examples)

**Level 3: Full Model Fine-Tuning**

- **Description**: Fine-tune entire pre-trained model on your data
- **Effort**: 1-3 months
- **Cost**: $25K-$150K one-time + ongoing
- **Quality**: 85-95% of optimal
- **Best for**: Substantial domain data (100K-10M examples), clear performance gaps

**Level 4: Train From Scratch**

- **Description**: Design and train custom architecture for your specific requirements
- **Effort**: 6-18 months
- **Cost**: $500K-$5M+ one-time + ongoing
- **Quality**: 95-100% optimal (when done right)
- **Best for**: Highly specialized domains, massive data (10M+ examples), competitive moat

:::{.callout-tip}
## The 80/20 Rule
For most organizations, **Level 3 (Full Model Fine-Tuning)** delivers 95% of the benefit at 20% of the cost compared to training from scratch. Only pursue Level 4 if embeddings are core to your competitive advantage.
:::

### Decision Framework: When to Build Custom

Use this framework to determine your approach. For each factor, assess whether your situation favors fine-tuning an existing model or building custom embeddings from scratch:

| Factor | Favors Fine-Tuning | Favors Custom |
|--------|-------------------|---------------|
| **Training data** | <1M labeled examples | >10M labeled examples |
| **Domain gap** | Low/medium (medical, financial) | High (genomics, specialized legal, non-text) |
| **Performance requirement** | "Good enough" for business needs | World-class, no compromises |
| **Specialized requirements** | Standard text/image | Multi-modal without pre-trained options, tiny models for edge, interpretability |
| **Budget** | <$150K | >$500K |
| **Timeline** | <6 months | >12 months |
| **Team capability** | Limited ML expertise | Published researchers, prior large model experience |
| **Competitive advantage** | Embeddings support product | Embeddings ARE the product/moat |

**How to interpret**: If most factors point toward fine-tuning, start with Level 2 or 3. If several factors strongly favor custom (especially domain gap and competitive advantage), consider Level 4.

**The hybrid path**: When factors are mixed, start with fine-tuning to establish a baseline and prove business value. This de-risks the investment before committing to custom development. Many successful systems follow this pattern—ship a fine-tuned model in months, then build custom after validating the opportunity.

### Illustrative Case Studies

:::{.callout-note}
The following case studies are hypothetical examples designed to illustrate decision-making patterns. While based on realistic scenarios and typical project parameters, they are not descriptions of specific real-world implementations.
:::

**Case Study 1: Medical Literature Search (Fine-Tuning Win)**

Consider a medical research platform that might initially consider training custom embeddings for biomedical literature. They might have:

- 500K labeled medical article pairs
- Medium domain gap (medical terminology specialized but well-covered in pre-training)
- 3-month timeline
- $100K budget

**Potential Decision**: Fine-tune BioBERT (domain-specific BERT variant already pre-trained on PubMed)

**Potential Outcome**:

- Could achieve ~91% of custom model performance at ~10% of cost
- Could launch in ~2 months vs. 12+ months for custom
- Fine-tuning cost: ~$40K one-time
- Performance: ~0.847 MRR (Mean Reciprocal Rank) vs. ~0.812 for frozen BioBERT

**Case Study 2: Genomics Sequence Embeddings (Custom Win)**

Consider a genomics company that might need embeddings for DNA/protein sequences. They might have:

- 50M protein sequences with structural/functional annotations
- Extreme domain gap (genomic sequences fundamentally different from text)
- 18-month timeline
- $2M budget
- World-class performance requirement (competitive moat)

**Potential Decision**: Build custom transformer architecture designed specifically for sequences

**Potential Outcome**:

- Custom architecture could outperform adapted text models by ~34%
- Could enable novel capabilities (structure prediction, functional annotation)
- Development cost: ~$1.8M over ~16 months
- Result: Potential industry-leading model, published research, patent applications

**Key Lesson**: Domain gap is often the decisive factor. Natural language pre-training provides limited transfer to genomic sequences.

**Case Study 3: E-commerce Search (Hybrid Approach)**

Consider an e-commerce platform with 100M products that might need multi-modal (text + image) embeddings:

**Phase 1 (Months 1-3)**: Could fine-tune CLIP on ~2M product images + descriptions

- Cost: ~$50K
- Result: Could achieve ~28% improvement over generic CLIP
- Launch to production, validate business impact

**Phase 2 (Months 4-12)**: Could build custom architecture incorporating product catalog structure

- Cost: ~$400K
- Result: Could achieve additional ~15% improvement over fine-tuned CLIP
- Could enable category-aware search, better handling of attributes

**Key Lesson**: A hybrid approach can de-risk investment. Fine-tuning provides fast wins; custom models deliver competitive advantage after proving value.

### The Fine-Tuning Recipe

When fine-tuning is the right choice, follow this battle-tested recipe:

```{python}
#| echo: true
#| code-fold: true
#| code-summary: "Show embedding fine-tuner implementation"
from sentence_transformers import InputExample, SentenceTransformer, losses
from torch.utils.data import DataLoader

class EmbeddingFineTuner:
    """Production-ready fine-tuning for sentence embeddings"""

    def __init__(self, base_model_name="all-mpnet-base-v2"):
        self.model = SentenceTransformer(base_model_name)
        self.base_model_name = base_model_name

    def prepare_training_data(self, examples):
        """Prepare training data (query, positive, optional negative)"""
        train_examples = []
        for ex in examples:
            if "negative" in ex:
                train_examples.append(InputExample(texts=[ex["query"], ex["positive"], ex["negative"]]))
            else:
                train_examples.append(InputExample(texts=[ex["query"], ex["positive"]], label=1.0))
        return DataLoader(train_examples, shuffle=True, batch_size=16)

    def fine_tune(self, train_dataloader, num_epochs=3, loss_function="cosine", warmup_steps=100):
        """Fine-tune with cosine, triplet, or contrastive loss"""
        if loss_function == "cosine":
            train_loss = losses.CosineSimilarityLoss(self.model)
        elif loss_function == "triplet":
            train_loss = losses.TripletLoss(model=self.model, triplet_margin=0.5)
        elif loss_function == "contrastive":
            train_loss = losses.ContrastiveLoss(self.model)

        self.model.fit(
            train_objectives=[(train_dataloader, train_loss)],
            epochs=num_epochs, warmup_steps=warmup_steps,
            optimizer_params={"lr": 2e-5}, show_progress_bar=True
        )

    def save_model(self, output_path):
        self.model.save(output_path)

# Usage example
training_data = [
    {"query": "comfortable running shoes", "positive": "Nike Air Zoom - cushioning for running",
     "negative": "Nike Basketball Shoes - high-top for court"},
]
finetuner = EmbeddingFineTuner(base_model_name="all-mpnet-base-v2")
print(f"Fine-tuner initialized with model: {finetuner.base_model_name}")
```

:::{.callout-important}
## Fine-Tuning Pitfalls
Common mistakes that tank fine-tuning performance:

1. **Insufficient data**: Need 10K+ examples minimum, 100K+ for best results
2. **Poor negative sampling**: Random negatives too easy; model doesn't learn distinction
3. **Catastrophic forgetting**: Fine-tuning destroys general capabilities; use lower learning rates
4. **Overfitting to training distribution**: Test on out-of-distribution examples
:::

## Domain-Specific Embedding Requirements

Generic embeddings optimize for average performance across diverse tasks. Domain-specific embeddings optimize for your specific requirements. Understanding and articulating these requirements is critical for successful custom embedding development.

### Taxonomy of Domain-Specific Requirements

**1. Semantic Granularity**

How fine-grained must similarity be?

| Granularity | Example Use Case | Requirement | Embedding Dim | Training Data |
|-------------|------------------|-------------|---------------|---------------|
| **Coarse-grained** | News article categorization | Distinguish broad topics (sports vs. politics vs. technology) | 128-256 | 10K-100K examples |
| **Medium-grained** | E-commerce product search | Distinguish product types and attributes (running shoes vs. hiking boots) | 256-512 | 100K-1M examples |
| **Fine-grained** | Legal document retrieval | Distinguish subtle legal distinctions (contract types, precedent applicability) | 512-768 | 1M-10M examples |
| **Ultra-fine** | Molecular drug discovery | Distinguish molecules with minor structural differences that dramatically affect properties | 768-1024+ | 10M+ examples or sophisticated augmentation |

**The Granularity-Dimension Relationship**: Finer semantic distinctions require higher-dimensional embeddings. You cannot reliably distinguish 10,000 fine-grained categories in 128 dimensions—the information simply doesn't fit.

**2. Asymmetric Similarity**

Are similarities symmetric or asymmetric? In asymmetric tasks, the query and document have fundamentally different characteristics:

- **Queries** are typically short, focused, and incomplete
- **Documents** are longer, complete, and information-rich

The key architectural pattern: **use separate encoders for queries and documents**. For example, "running shoes" (query) → "Nike Air Zoom Pegasus..." (document) has HIGH similarity, but reversing this comparison yields LOWER similarity because the specific product name is too narrow.

**Common Asymmetric Use Cases:**

| Domain | Query Type | Target Type | Why Asymmetric |
|--------|-----------|-------------|----------------|
| **Question Answering** | Short question | Long passage with answer | Question seeks answer; answer does not seek question |
| **Web Search** | 2-5 keywords | Full web page content | Query is intent; document is content |
| **Image Search** | Text description | Image | Cross-modal: text → image different from image → text |
| **Recommendation** | User behavior history | Product catalog | User history implies preferences; products have features |

**Why Asymmetric Matters**: Using symmetric embeddings (same encoder for queries and documents) for asymmetric tasks leaves performance on the table. Specialized encoders can optimize for each side's characteristics.

**3. Multi-Faceted Similarity**

Do items have multiple aspects of similarity? Many domains require representing different facets of similarity in separate embedding spaces. The key architectural pattern: **use separate encoders for different aspects, then combine with weighted fusion**.

**Example: E-commerce Products**

Products can be similar in multiple independent ways:

- **Visual facet**: Appearance, color, texture, shape (image encoder)
- **Functional facet**: Use case, purpose, features (text encoder on descriptions)
- **Attribute facet**: Brand, price tier, category (structured data encoder)

At search time, encode the query for each applicable facet, search each facet independently, then combine results with weights like `{visual: 0.4, functional: 0.4, attributes: 0.2}`. This allows tuning the balance between "looks like" vs "used for" vs "same brand/price" depending on the query.

**Multi-Faceted Use Cases**:

- **E-commerce**: Visual similarity (looks like), functional similarity (used for same purpose), price similarity
- **Movies**: Genre similarity, cast similarity, theme similarity, visual style similarity
- **Scientific papers**: Topic similarity, methodology similarity, citation network similarity
- **Recipes**: Ingredient similarity, cuisine similarity, difficulty similarity, taste profile similarity

**4. Temporal Dynamics**

Does similarity change over time? Real-world entities evolve: user interests shift, document relevance decays, product popularity cycles, and word meanings drift. Temporal embeddings capture this time dimension.

**Architectural Approaches:**

1. **Time encoding**: Concatenate static content embedding with time encoding (positional or learned), resulting in embeddings like `[static_emb (448d), time_emb (64d)]`
2. **Time-decayed similarity**: Apply exponential decay to similarity scores based on temporal distance (e.g., 180-day half-life: `decay = exp(-days/180)`)
3. **Time-sliced embeddings**: Maintain separate embeddings per time window (quarterly, yearly)

**Temporal Use Cases:**

| Domain | Requirement | Approach |
|--------|-------------|----------|
| **News Search** | Recent articles more relevant for most queries | Time decay on similarity scores |
| **Social Media** | Trending topics change rapidly | Short-window embeddings, frequent retraining |
| **Fashion/Trends** | Style similarity depends on current trends | Time-conditioned embeddings, seasonal retraining |
| **Scientific Research** | Paradigm shifts change what's similar | Period-specific embeddings (pre/post major discoveries) |

**5. Hierarchical Structure**

Do your items have natural hierarchies? Many domains have inherent taxonomies: product categories, organizational structures, disease classifications, and topic hierarchies. The key architectural pattern: **encode at different hierarchy levels with different dimensionality**.

**Example: E-commerce Hierarchy**

- **Category** (coarse): "Electronics" → 256-dim embedding
- **Subcategory** (medium): "Smartphones" → 512-dim embedding
- **Product** (fine): "iPhone 15 Pro Max 256GB" → 768-dim embedding

Coarse queries ("electronics") match at category level, while fine queries ("iphone 15 pro max") match at product level. The system classifies query specificity and searches at the appropriate hierarchy level.

**Benefits**: Enables both broad exploration ("show me electronics") and precise matching ("find this exact phone model") within a unified architecture.

### Domain-Specific Training Objectives

Different domains require different training objectives:

```{python}
#| echo: true
#| code-fold: true
#| code-summary: "Show domain-specific training objectives"
import torch
import torch.nn.functional as F

class DomainSpecificObjectives:
    """Domain-specific training objectives beyond standard contrastive learning"""

    def ranking_loss(self, query_emb, doc_embs, relevance_labels):
        """Ranking loss: Learn to order documents by relevance"""
        scores = torch.matmul(query_emb, doc_embs.T)
        loss = 0
        for i in range(len(doc_embs)):
            for j in range(i + 1, len(doc_embs)):
                if relevance_labels[i] > relevance_labels[j]:
                    loss += torch.clamp(1.0 - (scores[i] - scores[j]), min=0.0)
        return loss / (len(doc_embs) * (len(doc_embs) - 1) / 2)

    def attribute_preservation_loss(self, embedding, attributes):
        """Ensure embeddings preserve important attributes (category, brand, price)"""
        losses = []
        for attr_name, attr_value in attributes.items():
            attr_classifier = self.attribute_classifiers[attr_name]
            pred = attr_classifier(embedding)
            loss = F.cross_entropy(pred, attr_value)
            losses.append(loss)
        return sum(losses)

    def diversity_loss(self, embeddings):
        """Encourage embedding diversity (avoid collapse)"""
        pairwise_sim = torch.matmul(embeddings, embeddings.T)
        mask = ~torch.eye(len(embeddings), dtype=torch.bool)
        return pairwise_sim[mask].mean()

# Usage example
objectives = DomainSpecificObjectives()
print("Domain objectives: ranking, attribute preservation, diversity, cross-domain alignment")
```

## Multi-Objective Embedding Design

Most real-world embedding systems must optimize for multiple objectives simultaneously. Single-objective optimization leaves performance on the table.

### The Multi-Objective Challenge

Consider an e-commerce search system. The embedding should:

1. **Semantic relevance**: Match customer intent
2. **Attribute accuracy**: Preserve product attributes (category, brand, price)
3. **Personalization**: Adapt to user preferences
4. **Business metrics**: Optimize for conversion, revenue, not just clicks
5. **Diversity**: Avoid filter bubbles, show variety

Optimizing for one objective often degrades others. Multi-objective design balances these trade-offs.

### Multi-Objective Architecture Patterns

**Pattern 1: Multi-Task Learning**

Train single model with multiple heads:

```python
import torch
import torch.nn as nn

class MultiTaskEmbeddingModel(nn.Module):
    """
    Single encoder with multiple task-specific heads
    """

    def __init__(self, embedding_dim=512, num_categories=1000, num_brands=5000):
        super().__init__()

        # Shared encoder (e.g., transformer)
        self.shared_encoder = TransformerEncoder(
            dim=embedding_dim,
            depth=6,
            heads=8
        )

        # Task-specific heads
        self.similarity_head = nn.Linear(embedding_dim, embedding_dim)  # For similarity search
        self.category_head = nn.Linear(embedding_dim, num_categories)   # Category classification
        self.brand_head = nn.Linear(embedding_dim, num_brands)          # Brand classification
        self.price_head = nn.Linear(embedding_dim, 1)                   # Price regression

    def forward(self, input_ids, attention_mask):
        """
        Forward pass through shared encoder
        """
        # Shared representation
        hidden_state = self.shared_encoder(input_ids, attention_mask)
        pooled = hidden_state.mean(dim=1)  # Average pooling

        # Task-specific outputs
        outputs = {
            'embedding': self.similarity_head(pooled),
            'category_logits': self.category_head(pooled),
            'brand_logits': self.brand_head(pooled),
            'price_pred': self.price_head(pooled)
        }

        return outputs

    def compute_loss(self, outputs, targets, task_weights):
        """
        Weighted multi-task loss
        """
        losses = {}

        # Similarity loss (contrastive or triplet)
        if 'positive' in targets and 'negative' in targets:
            pos_sim = F.cosine_similarity(outputs['embedding'], targets['positive'])
            neg_sim = F.cosine_similarity(outputs['embedding'], targets['negative'])
            losses['similarity'] = torch.clamp(1.0 - pos_sim + neg_sim, min=0.0).mean()

        # Category classification loss
        if 'category' in targets:
            losses['category'] = F.cross_entropy(
                outputs['category_logits'],
                targets['category']
            )

        # Brand classification loss
        if 'brand' in targets:
            losses['brand'] = F.cross_entropy(
                outputs['brand_logits'],
                targets['brand']
            )

        # Price regression loss
        if 'price' in targets:
            losses['price'] = F.mse_loss(
                outputs['price_pred'].squeeze(),
                targets['price']
            )

        # Weighted combination
        total_loss = sum(
            task_weights.get(task, 1.0) * loss
            for task, loss in losses.items()
        )

        return total_loss, losses


# Training with multi-task learning
model = MultiTaskEmbeddingModel(embedding_dim=512)

# Task weights (tune based on importance)
task_weights = {
    'similarity': 1.0,   # Core task
    'category': 0.3,     # Help preserve category info
    'brand': 0.2,        # Help preserve brand info
    'price': 0.1         # Weak signal for price tier
}

# Training loop
optimizer = torch.optim.AdamW(model.parameters(), lr=2e-5)

for batch in train_loader:
    outputs = model(batch['input_ids'], batch['attention_mask'])

    loss, task_losses = model.compute_loss(
        outputs,
        targets=batch['targets'],
        task_weights=task_weights
    )

    optimizer.zero_grad()
    loss.backward()
    optimizer.step()
```

**Pattern 2: Multi-Vector Representations**

Use separate embeddings for different objectives:

```python
class MultiVectorEmbedding:
    """
    Represent items with multiple specialized embeddings
    """

    def __init__(self):
        # Different encoders for different aspects
        self.semantic_encoder = SemanticEncoder(dim=512)     # Semantic meaning
        self.structural_encoder = StructuralEncoder(dim=256)  # Structured attributes
        self.behavioral_encoder = BehavioralEncoder(dim=256)  # User interaction patterns

    def encode(self, item, user_context=None):
        """
        Create multi-vector representation
        """
        vectors = {}

        # Semantic vector: text content
        vectors['semantic'] = self.semantic_encoder.encode(
            item['title'] + ' ' + item['description']
        )

        # Structural vector: categorical attributes
        vectors['structural'] = self.structural_encoder.encode({
            'category': item['category'],
            'brand': item['brand'],
            'price_tier': self.discretize_price(item['price']),
            'rating': item['avg_rating']
        })

        # Behavioral vector: how users interact with this item
        if 'user_interactions' in item:
            vectors['behavioral'] = self.behavioral_encoder.encode(
                item['user_interactions']
            )

        return vectors

    def search(self, query, user_context=None, objective='balanced'):
        """
        Search with different objectives
        """
        # Encode query with multiple vectors
        query_vectors = self.encode_query(query, user_context)

        # Different objectives use different vector combinations
        if objective == 'relevance':
            # Focus on semantic similarity
            weights = {'semantic': 1.0, 'structural': 0.2, 'behavioral': 0.1}
        elif objective == 'personalization':
            # Focus on behavioral patterns
            weights = {'semantic': 0.3, 'structural': 0.2, 'behavioral': 1.0}
        elif objective == 'balanced':
            # Balance all factors
            weights = {'semantic': 0.5, 'structural': 0.3, 'behavioral': 0.2}
        elif objective == 'exploration':
            # Emphasize diversity (structural differences)
            weights = {'semantic': 0.3, 'structural': 0.7, 'behavioral': 0.1}

        # Search each vector space
        results_by_vector = {}
        for vector_type, query_vec in query_vectors.items():
            results_by_vector[vector_type] = self.search_vector_space(
                query_vec,
                vector_space=vector_type
            )

        # Combine results with objective-specific weights
        final_results = self.weighted_fusion(results_by_vector, weights)

        return final_results
```

**Pattern 3: Composite Objectives with Constraints**

Optimize primary objective subject to constraints:

```{python}
#| echo: true
#| code-fold: true
#| code-summary: "Show constrained embedding objective"
class ConstrainedEmbeddingObjective:
    """Optimize embeddings with hard constraints"""

    def __init__(self):
        self.primary_objective = "relevance"
        self.constraints = [
            {"type": "diversity", "threshold": 0.3},   # Min 30% diversity
            {"type": "freshness", "threshold": 0.5},   # Min 50% from last 30 days
            {"type": "price_range", "threshold": 0.2}, # Min 20% price range coverage
        ]

    def search_with_constraints(self, query, k=20):
        """Retrieve results satisfying constraints"""
        candidates = self.retrieve_candidates(query, k=k * 10)  # 10x oversampling
        return self.constrained_reranking(candidates, self.constraints, k)

    def constrained_reranking(self, candidates, constraints, k):
        """Rerank candidates to satisfy constraints while maximizing relevance"""
        selected, remaining = [], candidates.copy()
        while len(selected) < k and remaining:
            best_candidate, best_score = None, -float("inf")
            for candidate in remaining:
                temp_selected = selected + [candidate]
                if self.satisfies_constraints(temp_selected, constraints):
                    if candidate["relevance_score"] > best_score:
                        best_candidate, best_score = candidate, candidate["relevance_score"]
            if best_candidate:
                selected.append(best_candidate)
                remaining.remove(best_candidate)
            else:
                break
        return selected

    def satisfies_constraints(self, selected, constraints):
        """Check if selected results satisfy all constraints"""
        for c in constraints:
            if c["type"] == "diversity" and self.compute_diversity(selected) < c["threshold"]:
                return False
        return True

# Usage example
constrained = ConstrainedEmbeddingObjective()
print(f"Constraints: {[c['type'] for c in constrained.constraints]}")
```

### Balancing Trade-offs: The Pareto Frontier

Multi-objective optimization involves trade-offs. Visualize and navigate the Pareto frontier:

```{python}
#| echo: true
#| code-fold: true
#| code-summary: "Show multi-objective optimization"
class MultiObjectiveOptimization:
    """Navigate trade-offs between multiple objectives"""

    def compute_pareto_frontier(self, models, test_data):
        """Compute Pareto frontier across objectives"""
        evaluations = []
        for model in models:
            metrics = {
                "model": model,
                "relevance": self.evaluate_relevance(model, test_data),
                "diversity": self.evaluate_diversity(model, test_data),
                "personalization": self.evaluate_personalization(model, test_data),
                "business_metrics": self.evaluate_business(model, test_data),
            }
            evaluations.append(metrics)

        # Find Pareto-optimal models (not dominated by any other)
        pareto_optimal = []
        for eval_i in evaluations:
            dominated = False
            for eval_j in evaluations:
                if eval_i != eval_j and self.dominates(eval_j, eval_i):
                    dominated = True
                    break
            if not dominated:
                pareto_optimal.append(eval_i)
        return pareto_optimal

    def dominates(self, eval_a, eval_b):
        """Check if eval_a dominates eval_b (better on all objectives)"""
        objectives = ["relevance", "diversity", "personalization", "business_metrics"]
        better_on_at_least_one = False
        for obj in objectives:
            if eval_a[obj] < eval_b[obj]:
                return False
            if eval_a[obj] > eval_b[obj]:
                better_on_at_least_one = True
        return better_on_at_least_one

    def select_operating_point(self, pareto_frontier, business_priorities):
        """Select model from Pareto frontier based on business priorities"""
        best_model, best_score = None, -float("inf")
        for eval_point in pareto_frontier:
            weighted_score = sum(
                business_priorities.get(obj, 0) * eval_point[obj]
                for obj in ["relevance", "diversity", "personalization", "business_metrics"]
            )
            if weighted_score > best_score:
                best_score, best_model = weighted_score, eval_point["model"]
        return best_model

# Usage example
optimizer = MultiObjectiveOptimization()
print("Multi-objective: relevance, diversity, personalization, business metrics")
```

## Embedding Dimensionality Optimization

Embedding dimensionality has profound impacts on performance, cost, and latency. Too low: information loss. Too high: computational waste and overfitting. Finding the optimal dimensionality is critical for production systems.

### The Dimensionality Trade-off

| Dimension | Storage (100B embeddings) | QPS (single server) | Pros | Cons |
|-----------|---------------------------|---------------------|------|------|
| 128 | 48 TB | 50,000 | Extremely fast, cheap | Limited capacity |
| 256 | 96 TB | 35,000 | Good balance | May lose fine-grained information |
| 512 | 192 TB | 18,000 | High capacity | 2x cost vs. 256 |
| 768 | 288 TB | 12,000 | BERT standard | 3x cost vs. 256 |
| 1024 | 384 TB | 9,000 | Maximum capacity | 4x cost, often overkill |

### Determining Optimal Dimensionality

**Method 1: Empirical Evaluation**

```{python}
#| echo: true
#| code-fold: true
#| code-summary: "Show dimensionality experiment"
import pandas as pd

class DimensionalityExperiment:
    """Systematically evaluate different embedding dimensions"""

    def run_dimensionality_sweep(self, train_data, test_data, dimensions=None):
        """Train models at different dimensions and evaluate"""
        if dimensions is None:
            dimensions = [128, 256, 384, 512, 768]
        results = []

        for dim in dimensions:
            model = self.train_model(train_data, embedding_dim=dim)
            metrics = self.evaluate_model(model, test_data)
            storage_gb = self.estimate_storage(dim, num_embeddings=100_000_000)
            latency_ms = self.measure_latency(model)

            results.append({
                "dimension": dim, "recall@10": metrics["recall@10"], "mrr": metrics["mrr"],
                "storage_gb": storage_gb, "p99_latency_ms": latency_ms,
            })
        return pd.DataFrame(results)

    def find_optimal_dimension(self, results, quality_threshold=0.95):
        """Find smallest dimension meeting quality threshold"""
        max_recall = results["recall@10"].max()
        results["normalized_quality"] = results["recall@10"] / max_recall
        acceptable = results[results["normalized_quality"] >= quality_threshold]
        if acceptable.empty:
            return results.loc[results["recall@10"].idxmax(), "dimension"]
        return acceptable.loc[acceptable["dimension"].idxmin(), "dimension"]

# Example results:
# | Dim  | Recall@10 | Storage | Quality |
# |------|-----------|---------|---------|
# | 128  | 0.834     | 48 GB   | 0.909   |
# | 256  | 0.891     | 96 GB   | 0.972   |
# | 384  | 0.908     | 144 GB  | 0.991   | ← Optimal (99.1% quality, 50% cheaper than 768)
# | 512  | 0.915     | 192 GB  | 0.998   |
# | 768  | 0.917     | 288 GB  | 1.000   |
experiment = DimensionalityExperiment()
print("Dimensions to test: [128, 256, 384, 512, 768]")
```

**Method 2: Intrinsic Dimensionality Estimation**

Estimate the intrinsic dimensionality of your data:

```{python}
#| echo: true
#| code-fold: true
#| code-summary: "Show intrinsic dimensionality estimation"
import numpy as np
from sklearn.decomposition import PCA
from sklearn.neighbors import NearestNeighbors

class IntrinsicDimensionality:
    """Estimate intrinsic dimensionality of embedding space"""

    def estimate_via_pca(self, embeddings, variance_threshold=0.95):
        """Use PCA to find dimensions capturing X% of variance"""
        pca = PCA()
        pca.fit(embeddings)
        cumsum_variance = np.cumsum(pca.explained_variance_ratio_)
        n_components = np.argmax(cumsum_variance >= variance_threshold) + 1
        return {"intrinsic_dimension": n_components, "variance_captured": cumsum_variance[n_components - 1]}

    def estimate_via_mle(self, embeddings, k=10):
        """MLE estimation (Levina & Bickel 2004)"""
        nbrs = NearestNeighbors(n_neighbors=k + 1).fit(embeddings)
        distances, _ = nbrs.kneighbors(embeddings)
        distances = distances[:, 1:]  # Remove self
        dimensions = []
        for dist_vec in distances:
            r_k = dist_vec[-1]
            if r_k > 0:
                log_ratios = np.log(r_k / dist_vec[:-1])
                if log_ratios.sum() > 0:
                    dimensions.append((k - 1) / log_ratios.sum())
        return {"intrinsic_dimension": int(np.median(dimensions))}

# Usage example
embeddings = np.random.randn(1000, 768).astype(np.float32)
estimator = IntrinsicDimensionality()
pca_result = estimator.estimate_via_pca(embeddings, variance_threshold=0.95)
print(f"PCA estimate: {pca_result['intrinsic_dimension']} dims capture 95% variance")
```

**Method 3: Progressive Dimensionality Reduction**

Train high-dimensional model, then compress:

```{python}
#| echo: true
#| code-fold: true
#| code-summary: "Show progressive dimension reduction"
import torch
import torch.nn as nn
import torch.nn.functional as F

class ProgressiveDimensionReduction:
    """Start with high dimensions, progressively reduce while monitoring quality"""

    def __init__(self, base_model, original_dim=768):
        self.base_model = base_model
        self.original_dim = original_dim

    def train_projection(self, embeddings, target_dim):
        """Learn projection from high-dim to low-dim"""
        projection_net = nn.Linear(self.original_dim, target_dim)
        optimizer = torch.optim.Adam(projection_net.parameters(), lr=1e-3)

        for _epoch in range(10):
            idx1 = torch.randint(0, len(embeddings), (1000,))
            idx2 = torch.randint(0, len(embeddings), (1000,))
            orig_sim = F.cosine_similarity(embeddings[idx1], embeddings[idx2])
            proj_sim = F.cosine_similarity(projection_net(embeddings[idx1]), projection_net(embeddings[idx2]))
            loss = F.mse_loss(proj_sim, orig_sim)
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()
        return projection_net

    def find_minimal_dimension(self, embeddings, test_data, quality_threshold=0.95):
        """Binary search for minimal dimension meeting quality threshold"""
        original_quality = self.evaluate(self.base_model, test_data)
        target_quality = original_quality * quality_threshold
        low, high, best_dim = 64, self.original_dim, self.original_dim

        while low <= high:
            mid = (low + high) // 2
            projection = self.train_projection(embeddings, target_dim=mid)
            quality = self.evaluate_with_projection(self.base_model, projection, test_data)
            if quality >= target_quality:
                best_dim, high = mid, mid - 1
            else:
                low = mid + 1
        return best_dim

# Usage example
print("Progressive reduction: 768 → find minimal dim maintaining 95% quality")
```

### Dimension-Specific Optimizations

Different dimensions enable different optimizations:

**Ultra-Low Dimensions (64-128): Binary/Hamming Embeddings**

```{python}
#| echo: true
#| code-fold: true
#| code-summary: "Show binary embeddings for ultra-compression"
import numpy as np

class BinaryEmbeddings:
    """Ultra-compressed binary embeddings for massive scale"""

    def binarize(self, embeddings):
        """
        Convert float embeddings to binary
        768-dim float32 → 96 bytes
        768-dim binary → 96 bits = 12 bytes (8x compression)
        """
        binary = (embeddings > 0).astype(np.uint8)
        return np.packbits(binary, axis=1)

    def hamming_similarity(self, binary1, binary2):
        """Ultra-fast similarity using Hamming distance"""
        xor = np.bitwise_xor(binary1, binary2)
        hamming_dist = np.unpackbits(xor).sum()
        max_dist = len(binary1) * 8
        return 1 - (hamming_dist / max_dist)

# Usage example
embeddings = np.random.randn(100, 768).astype(np.float32)
binary_emb = BinaryEmbeddings()
packed = binary_emb.binarize(embeddings)
print(f"Original: {embeddings.nbytes:,} bytes → Binary: {packed.nbytes:,} bytes ({embeddings.nbytes/packed.nbytes:.0f}x compression)")
# Binary enables: 8x compression, 10-100x faster search via POPCOUNT
```

## Cost-Performance Trade-offs at Scale

At trillion-row scale, the cost-performance trade-off becomes the dominant factor in embedding design. This section provides frameworks for optimizing this trade-off.

### Total Cost of Ownership (TCO) Model

Embedding TCO comprises four major components:

1. **Storage costs**: Embeddings + indexing overhead + replication
2. **Training costs**: Model development + periodic retraining
3. **Inference costs**: Query processing + vector database operations
4. **Team costs**: Engineering, ML, and operations personnel

```{python}
#| echo: true
#| code-fold: true
#| code-summary: "Show storage cost calculation"
def compute_storage_cost(num_embeddings, dim, duration_years=3):
    """Calculate storage cost with realistic overhead"""
    # Cloud pricing (approximate, as of 2024)
    storage_cost_per_gb_month = 0.023  # S3 standard

    bytes_per_embedding = dim * 4  # float32
    total_bytes = num_embeddings * bytes_per_embedding

    # Index overhead (HNSW adds ~50%)
    indexed_bytes = total_bytes * 1.5

    # Replication (3x for availability)
    replicated_bytes = indexed_bytes * 3

    # Convert to GB
    total_gb = replicated_bytes / (1024 ** 3)

    # Monthly cost
    monthly_cost = total_gb * storage_cost_per_gb_month

    # Total over duration
    return monthly_cost * 12 * duration_years

# Example: 100B embeddings at 768 dimensions
storage_cost_3yr = compute_storage_cost(
    num_embeddings=100_000_000_000,
    dim=768,
    duration_years=3
)
print(f"Storage cost (100B embeddings, 768-dim, 3 years): ${storage_cost_3yr:,.0f}")
```

**TCO Example (100B embeddings, 768-dim, 3 years)**:

- Storage: ~$12M (embeddings + HNSW index + 3x replication)
- Training: ~$5M (periodic retraining, 4x/year)
- Inference: ~$25M (10K QPS @ $10/million queries)
- Team: ~$5M (10-person team, fully loaded)
- **Total: ~$47M over 3 years** (~$16M/year)

**Cost optimization** through dimension reduction (768→256), quantization (float32→int8), and tiered storage can reduce total costs by 80-90%.

### Performance-Cost Pareto Frontier

Navigate the trade-off space:

```{python}
#| echo: true
#| code-fold: true
#| code-summary: "Show cost-performance frontier analysis"
class CostPerformanceFrontier:
    """Explore cost-performance trade-offs"""

    def generate_configuration_space(self, requirements):
        """Generate configurations spanning cost-performance space"""
        configs = []
        dimensions = [128, 256, 384, 512, 768, 1024]
        quantizations = ["float32", "float16", "int8", "binary"]
        index_types = ["flat", "ivf", "hnsw", "pq"]

        for dim in dimensions:
            for quant in quantizations:
                for index in index_types:
                    config = {
                        "dimension": dim, "quantization": quant, "index_type": index,
                        "num_embeddings": requirements["num_embeddings"],
                    }
                    cost = self.estimate_cost(config)
                    performance = self.estimate_performance(config)
                    configs.append({
                        **config, "annual_cost": cost,
                        "p99_latency_ms": performance["latency"], "recall@10": performance["recall"],
                    })
        return configs

    def find_pareto_optimal(self, configs):
        """Find Pareto-optimal configurations"""
        pareto = []
        for c in configs:
            dominated = False
            for other in configs:
                if (other["recall@10"] >= c["recall@10"] and
                    other["annual_cost"] <= c["annual_cost"] and
                    other["p99_latency_ms"] <= c["p99_latency_ms"] and
                    (other["recall@10"] > c["recall@10"] or
                     other["annual_cost"] < c["annual_cost"] or
                     other["p99_latency_ms"] < c["p99_latency_ms"])):
                    dominated = True
                    break
            if not dominated:
                pareto.append(c)
        return pareto

# Usage example
frontier = CostPerformanceFrontier()
print("Configuration space: 6 dims × 4 quantizations × 4 indices = 96 configs")
```

### Cost Optimization Strategies

**Strategy 1: Tiered Embeddings**

Use different dimensions for different data tiers based on access frequency:

- **Hot tier** (>1000 queries/day): 768-dim embeddings for highest quality
- **Warm tier** (10-1000 queries/day): 384-dim embeddings for good balance
- **Cold tier** (<10 queries/day): 128-dim embeddings for acceptable quality at low cost

**Cost savings example**:

- 90% of embeddings in cold tier (128-dim): 83% storage savings
- 9% in warm tier (384-dim): 50% savings
- 1% in hot tier (768-dim): full quality
- **Overall: ~80% storage cost reduction**

## Key Takeaways

- **The build vs. fine-tune decision follows a spectrum** from using frozen pre-trained models (Level 0) to training custom architectures from scratch (Level 4)—most organizations should target Level 3 (full fine-tuning) which delivers 95% of benefits at 20% of cost

- **Domain-specific requirements shape embedding design** across five dimensions: semantic granularity (coarse to ultra-fine), asymmetry (query vs. document), multi-faceted similarity (multiple aspects), temporal dynamics (time-varying relevance), and hierarchical structure

- **Multi-objective embedding design balances competing goals** through multi-task learning (shared encoder with task-specific heads), multi-vector representations (separate embeddings per objective), or constrained optimization (optimize primary objective subject to constraints)

- **Optimal embedding dimensionality balances capacity and cost**—empirical evaluation across dimensions (128-1024) reveals diminishing returns beyond intrinsic dimensionality, with most domains achieving 95%+ quality at 256-512 dimensions vs. 768+ standard models

- **Dimensionality reduction techniques** including PCA-based compression, learned projections, and binary embeddings enable 8-10x cost savings while maintaining acceptable quality for many use cases

- **Total cost of ownership spans storage, training, inference, and team costs**—using the TCO model above, 100B embeddings at 768 dimensions would have annual costs around $47M, but optimization through dimension reduction (768→256), quantization (float32→int8), and tiered storage can achieve 90%+ cost savings

- **Cost-performance trade-offs navigate the Pareto frontier** where different configurations offer optimal points—no single configuration dominates all objectives, requiring explicit business priority weighting to select operating points

## Looking Ahead

@sec-contrastive-learning dives deep into contrastive learning—one of the most powerful techniques for training custom embeddings that achieve state-of-the-art performance across diverse domains.

## Further Reading

- Devlin, J., et al. (2018). "BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding." *arXiv:1810.04805*
- Reimers, N., & Gurevych, I. (2019). "Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks." *arXiv:1908.10084*
- Muennighoff, N., et al. (2022). "SGPT: GPT Sentence Embeddings for Semantic Search." *arXiv:2202.08904*
- Radford, A., et al. (2021). "Learning Transferable Visual Models From Natural Language Supervision." *arXiv:2103.00020* (CLIP)
- Chen, T., et al. (2020). "A Simple Framework for Contrastive Learning of Visual Representations." *arXiv:2002.05709* (SimCLR)
- Levina, E., & Bickel, P. (2004). "Maximum Likelihood Estimation of Intrinsic Dimension." *NIPS 2004*
- Jégou, H., et al. (2011). "Product Quantization for Nearest Neighbor Search." *IEEE TPAMI*
- Gong, Y., et al. (2020). "Quantization based Fast Inner Product Search." *AISTATS*
- Ruder, S. (2017). "An Overview of Multi-Task Learning in Deep Neural Networks." *arXiv:1706.05098*
- Caruana, R. (1997). "Multitask Learning." *Machine Learning* 28, 41–75
