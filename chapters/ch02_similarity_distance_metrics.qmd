# Similarity and Distance Metrics {#sec-similarity-distance-metrics}

::: callout-note
## Chapter Overview

Choosing the right similarity or distance metric fundamentally affects embedding system performance. This chapter covers the major metrics—cosine similarity, Euclidean distance, dot product, and others—explaining when to use each, their mathematical properties, and practical implications for vector databases and retrieval quality.
:::

## Why Metric Choice Matters

The metric you choose determines:

- **What "similar" means** for your application
- **Index performance** in your vector database
- **Retrieval quality** for your use case
- **Computational cost** at query time

Different metrics capture different notions of similarity. Two embeddings might be "close" by one metric and "far" by another. Understanding these differences is essential for building effective embedding systems.

## Cosine Similarity {#sec-cosine-similarity}

We introduced cosine similarity briefly in @sec-embedding-revolution; here we cover it in depth alongside other metrics so you can make informed choices.

Cosine similarity measures the angle between two vectors, ignoring their magnitudes:

$$\text{cosine\_similarity}(\mathbf{A}, \mathbf{B}) = \frac{\mathbf{A} \cdot \mathbf{B}}{||\mathbf{A}|| \times ||\mathbf{B}||} = \frac{\sum_{i=1}^{n} A_i B_i}{\sqrt{\sum_{i=1}^{n} A_i^2} \times \sqrt{\sum_{i=1}^{n} B_i^2}}$$

```{python}
#| label: fig-cosine-similarity
#| fig-cap: "Cosine similarity measures the angle θ between vectors, ignoring magnitude. Vectors A and B point in similar directions (high similarity) while C points differently (low similarity)."
#| echo: false

import matplotlib.pyplot as plt
import numpy as np

fig, ax = plt.subplots(figsize=(7, 5))

# Vectors from origin
origin = [0, 0]
A = [3, 2]
B = [4.5, 3]  # Similar direction to A
C = [1, 4]    # Different direction

# Draw vectors
ax.annotate('', xy=A, xytext=origin, arrowprops=dict(arrowstyle='->', color='#2563eb', lw=2.5))
ax.annotate('', xy=B, xytext=origin, arrowprops=dict(arrowstyle='->', color='#16a34a', lw=2.5))
ax.annotate('', xy=C, xytext=origin, arrowprops=dict(arrowstyle='->', color='#dc2626', lw=2.5))

# Labels
ax.text(A[0]+0.15, A[1]+0.15, 'A', fontsize=14, fontweight='bold', color='#2563eb')
ax.text(B[0]+0.15, B[1]+0.15, 'B', fontsize=14, fontweight='bold', color='#16a34a')
ax.text(C[0]+0.15, C[1]+0.15, 'C', fontsize=14, fontweight='bold', color='#dc2626')

# Draw angle arc between A and B
angle_A = np.arctan2(A[1], A[0])
angle_B = np.arctan2(B[1], B[0])
theta = np.linspace(angle_A, angle_B, 20)
r = 1.2
ax.plot(r * np.cos(theta), r * np.sin(theta), 'k-', lw=1.5)
ax.text(1.4, 0.85, 'θ (small)', fontsize=11)

# Draw angle arc between A and C
angle_C = np.arctan2(C[1], C[0])
theta2 = np.linspace(angle_A, angle_C, 30)
r2 = 0.8
ax.plot(r2 * np.cos(theta2), r2 * np.sin(theta2), 'k--', lw=1.5)
ax.text(0.3, 1.0, 'θ (large)', fontsize=11)

# Calculate similarities
def cosine_sim(a, b):
    return np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))

sim_AB = cosine_sim(A, B)
sim_AC = cosine_sim(A, C)

# Add similarity values
ax.text(3.5, 0.3, f'cos(A,B) = {sim_AB:.2f}', fontsize=11, color='#16a34a', fontweight='bold')
ax.text(1.3, 3.3, f'cos(A,C) = {sim_AC:.2f}', fontsize=11, color='#dc2626', fontweight='bold')

ax.set_xlim(-0.5, 5.5)
ax.set_ylim(-0.5, 4.5)
ax.set_aspect('equal')
ax.axhline(y=0, color='gray', linewidth=0.5)
ax.axvline(x=0, color='gray', linewidth=0.5)
ax.set_xlabel('Dimension 1', fontsize=11)
ax.set_ylabel('Dimension 2', fontsize=11)
ax.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()
```

```{python}
#| code-fold: false

"""
Cosine Similarity: Angle-Based Comparison

Measures the cosine of the angle between vectors.
Range: -1 (opposite) to 1 (identical direction)
"""

import numpy as np
from scipy.spatial.distance import cosine

def cosine_similarity(a, b):
    """Calculate cosine similarity (1 = identical, -1 = opposite)."""
    return np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))

# Example: Same direction, different magnitudes
v1 = np.array([1.0, 2.0, 3.0])
v2 = np.array([2.0, 4.0, 6.0])  # Same direction, 2x magnitude
v3 = np.array([3.0, 2.0, 1.0])  # Different direction

print("Cosine similarity examples:")
print(f"  v1 ↔ v2 (same direction, different magnitude): {cosine_similarity(v1, v2):.4f}")
print(f"  v1 ↔ v3 (different direction): {cosine_similarity(v1, v3):.4f}")
```

**When to use cosine similarity:**

- **Text embeddings**: Sentence transformers produce vectors where direction encodes meaning
- **High-dimensional spaces** (100+ dimensions): More stable than Euclidean distance
- **When magnitude isn't meaningful**: Document length shouldn't affect similarity
- **Normalized embeddings**: Most embedding models normalize output vectors

**Cosine distance** is simply `1 - cosine_similarity`, converting similarity to distance where 0 = identical.

## Euclidean Distance (L2) {#sec-euclidean-distance}

Euclidean distance measures the straight-line distance between two points:

$$\text{euclidean}(\mathbf{A}, \mathbf{B}) = \sqrt{\sum_{i=1}^{n} (A_i - B_i)^2} = ||\mathbf{A} - \mathbf{B}||_2$$

```{python}
#| label: fig-euclidean-distance
#| fig-cap: "Euclidean distance measures the straight-line distance between points. Unlike cosine similarity, magnitude matters—point B is far from A despite pointing in a similar direction."
#| echo: false

import matplotlib.pyplot as plt
import numpy as np

fig, ax = plt.subplots(figsize=(7, 5))

# Points in 2D space
A = np.array([1, 1])
B = np.array([4, 3])
C = np.array([2, 4])

# Plot points
ax.scatter(*A, s=150, c='#2563eb', zorder=5, edgecolors='white', linewidths=2)
ax.scatter(*B, s=150, c='#16a34a', zorder=5, edgecolors='white', linewidths=2)
ax.scatter(*C, s=150, c='#dc2626', zorder=5, edgecolors='white', linewidths=2)

# Labels
ax.text(A[0]-0.3, A[1]+0.3, 'A', fontsize=14, fontweight='bold', color='#2563eb')
ax.text(B[0]+0.15, B[1]+0.2, 'B', fontsize=14, fontweight='bold', color='#16a34a')
ax.text(C[0]+0.15, C[1]+0.2, 'C', fontsize=14, fontweight='bold', color='#dc2626')

# Draw distance lines
ax.plot([A[0], B[0]], [A[1], B[1]], 'g--', lw=2, alpha=0.7)
ax.plot([A[0], C[0]], [A[1], C[1]], 'r--', lw=2, alpha=0.7)

# Calculate distances
dist_AB = np.linalg.norm(A - B)
dist_AC = np.linalg.norm(A - C)

# Midpoint labels - offset away from lines
mid_AB = (A + B) / 2
mid_AC = (A + C) / 2
ax.text(mid_AB[0]+0.3, mid_AB[1]-0.5, f'd = {dist_AB:.2f}', fontsize=11, color='#16a34a', fontweight='bold')
ax.text(mid_AC[0]-1.3, mid_AC[1]-0.3, f'd = {dist_AC:.2f}', fontsize=11, color='#dc2626', fontweight='bold')

ax.set_xlim(0, 5)
ax.set_ylim(0, 5)
ax.set_aspect('equal')
ax.set_xlabel('Dimension 1', fontsize=11)
ax.set_ylabel('Dimension 2', fontsize=11)
ax.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()
```

```{python}
#| code-fold: false

"""
Euclidean Distance: Straight-Line Distance

Measures absolute separation in space.
Range: 0 (identical) to infinity
"""

import numpy as np

def euclidean_distance(a, b):
    """Calculate Euclidean (L2) distance."""
    return np.linalg.norm(a - b)

# Same vectors as before
v1 = np.array([1.0, 2.0, 3.0])
v2 = np.array([2.0, 4.0, 6.0])  # Same direction, 2x magnitude
v3 = np.array([3.0, 2.0, 1.0])  # Different direction

print("Euclidean distance examples:")
print(f"  v1 ↔ v2 (same direction, different magnitude): {euclidean_distance(v1, v2):.4f}")
print(f"  v1 ↔ v3 (different direction): {euclidean_distance(v1, v3):.4f}")
print("\nNote: v1 and v2 are FAR by Euclidean but IDENTICAL by cosine!")
```

**When to use Euclidean distance:**

- **Image embeddings**: When pixel-level differences matter
- **Low-dimensional spaces** (< 50 dimensions): Works well
- **When magnitude matters**: Larger vectors should be "farther"
- **Clustering applications**: K-means uses Euclidean distance

**Warning**: Euclidean distance suffers from the **curse of dimensionality**. In high dimensions (768+), all points tend to become equidistant, reducing discriminative power.

## Dot Product (Inner Product) {#sec-dot-product}

The dot product is the unnormalized version of cosine similarity:

$$\text{dot\_product}(\mathbf{A}, \mathbf{B}) = \mathbf{A} \cdot \mathbf{B} = \sum_{i=1}^{n} A_i B_i$$

```{python}
#| label: fig-dot-product
#| fig-cap: "Dot product combines angle AND magnitude. Vectors B and C point in nearly the same direction as A, but B (longer) has a higher dot product. Cosine similarity would rate all three pairs equally since it ignores magnitude."
#| echo: false

import matplotlib.pyplot as plt
import numpy as np

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))

# Left panel: vectors in exact same direction, different line styles
origin = [0, 0]
# All point in same direction (ratio 2:3)
A = np.array([3, 2])
B = np.array([4.5, 3])       # 1.5x magnitude, same direction
C = np.array([1.5, 1])       # 0.5x magnitude, same direction

# All dotted lines with varying opacity to distinguish
ax1.annotate('', xy=B, xytext=origin, arrowprops=dict(arrowstyle='->', color='#16a34a', lw=3, linestyle=':', alpha=1.0))
ax1.annotate('', xy=A, xytext=origin, arrowprops=dict(arrowstyle='->', color='#2563eb', lw=3, linestyle=':', alpha=0.6))
ax1.annotate('', xy=C, xytext=origin, arrowprops=dict(arrowstyle='->', color='#dc2626', lw=3, linestyle=':', alpha=0.4))

ax1.text(A[0]+0.15, A[1]+0.25, 'A', fontsize=11, fontweight='bold', color='#2563eb')
ax1.text(B[0]+0.15, B[1]+0.25, 'B (1.5×)', fontsize=11, fontweight='bold', color='#16a34a')
ax1.text(C[0]+0.15, C[1]-0.35, 'C (0.5×)', fontsize=11, fontweight='bold', color='#dc2626')

ax1.set_xlim(-0.5, 5.5)
ax1.set_ylim(-0.5, 4)
ax1.set_aspect('equal')
ax1.axhline(y=0, color='gray', linewidth=0.5)
ax1.axvline(x=0, color='gray', linewidth=0.5)
ax1.set_xlabel('Dimension 1', fontsize=11)
ax1.set_ylabel('Dimension 2', fontsize=11)
ax1.set_title('Vectors (similar direction, different lengths)', fontsize=11)
ax1.grid(True, alpha=0.3)

# Right panel: bar chart comparing metrics
dot_AB = np.dot(A, B)
dot_AC = np.dot(A, C)
cos_AB = dot_AB / (np.linalg.norm(A) * np.linalg.norm(B))
cos_AC = dot_AC / (np.linalg.norm(A) * np.linalg.norm(C))

x = np.arange(2)
width = 0.35

bars1 = ax2.bar(x - width/2, [dot_AB, dot_AC], width, label='Dot Product', color=['#16a34a', '#dc2626'], alpha=0.8)
bars2 = ax2.bar(x + width/2, [cos_AB * 20, cos_AC * 20], width, label='Cosine × 20', color=['#16a34a', '#dc2626'], alpha=0.4, hatch='//')

ax2.set_ylabel('Value', fontsize=11)
ax2.set_ylim(0, 26)  # Add top padding for labels and legend
ax2.set_title('Dot product varies with length;\nCosine stays constant', fontsize=11)
ax2.set_xticks(x)
ax2.set_xticklabels(['A · B\nvs\ncos(A,B)', 'A · C\nvs\ncos(A,C)'])
ax2.legend(loc='upper right', bbox_to_anchor=(1.0, 0.95))

# Add value labels
ax2.text(0 - width/2, dot_AB + 0.5, f'{dot_AB:.1f}', ha='center', fontsize=10, fontweight='bold')
ax2.text(1 - width/2, dot_AC + 0.5, f'{dot_AC:.1f}', ha='center', fontsize=10, fontweight='bold')
ax2.text(0 + width/2, cos_AB * 20 + 0.5, f'{cos_AB:.2f}', ha='center', fontsize=10)
ax2.text(1 + width/2, cos_AC * 20 + 0.5, f'{cos_AC:.2f}', ha='center', fontsize=10)

plt.tight_layout()
plt.show()
```

```{python}
#| code-fold: false

"""
Dot Product: Direction + Magnitude

Combines directional similarity with magnitude.
Range: -infinity to +infinity
"""

import numpy as np

def dot_product(a, b):
    """Calculate dot product."""
    return np.dot(a, b)

# Vectors with different magnitudes
v1 = np.array([1.0, 2.0, 3.0])
v2 = np.array([2.0, 4.0, 6.0])    # Same direction, 2x magnitude
v3 = np.array([0.5, 1.0, 1.5])    # Same direction, 0.5x magnitude

print("Dot product examples:")
print(f"  v1 · v1: {dot_product(v1, v1):.4f}")
print(f"  v1 · v2 (2x magnitude): {dot_product(v1, v2):.4f}")
print(f"  v1 · v3 (0.5x magnitude): {dot_product(v1, v3):.4f}")
print("\nDot product rewards both alignment AND magnitude")
```

**When to use dot product:**

- **Recommendation systems**: User-item relevance often uses dot product scoring
- **When magnitude encodes importance**: Higher-magnitude vectors are "stronger" matches
- **Maximum Inner Product Search (MIPS)**: Some vector DBs optimize for this
- **Pre-normalized embeddings**: Equivalent to cosine similarity when vectors are unit length

**Relationship to cosine similarity**: For unit-normalized vectors, dot product equals cosine similarity.

## Manhattan Distance (L1) {#sec-manhattan-distance}

Manhattan distance sums the absolute differences along each dimension:

$$\text{manhattan}(\mathbf{A}, \mathbf{B}) = \sum_{i=1}^{n} |A_i - B_i| = ||\mathbf{A} - \mathbf{B}||_1$$

```{python}
#| label: fig-manhattan-distance
#| fig-cap: "Manhattan distance follows a 'city block' path along axes (orange), while Euclidean takes the direct route (blue dashed). Manhattan = |4-1| + |3-1| = 5, while Euclidean = 3.61."
#| echo: false

import matplotlib.pyplot as plt
import numpy as np

fig, ax = plt.subplots(figsize=(7, 5))

A = np.array([1, 1])
B = np.array([4, 3])

# Plot points
ax.scatter(*A, s=150, c='#2563eb', zorder=5, edgecolors='white', linewidths=2)
ax.scatter(*B, s=150, c='#16a34a', zorder=5, edgecolors='white', linewidths=2)

# Labels
ax.text(A[0]-0.35, A[1]+0.2, 'A', fontsize=14, fontweight='bold', color='#2563eb')
ax.text(B[0]+0.15, B[1]+0.2, 'B', fontsize=14, fontweight='bold', color='#16a34a')

# Euclidean (direct line)
ax.plot([A[0], B[0]], [A[1], B[1]], 'b--', lw=2.5, label='Euclidean (L2)', alpha=0.7)

# Manhattan (city block path)
ax.plot([A[0], B[0]], [A[1], A[1]], 'orange', lw=3, solid_capstyle='round')
ax.plot([B[0], B[0]], [A[1], B[1]], 'orange', lw=3, solid_capstyle='round', label='Manhattan (L1)')

# Add arrows to show direction
ax.annotate('', xy=(2.5, 1), xytext=(1.5, 1), arrowprops=dict(arrowstyle='->', color='orange', lw=2))
ax.annotate('', xy=(4, 2), xytext=(4, 1.5), arrowprops=dict(arrowstyle='->', color='orange', lw=2))

# Calculate distances
euclidean = np.linalg.norm(A - B)
manhattan = np.sum(np.abs(A - B))

# Add distance labels
ax.text(2.5, 0.6, f'|Δx| = 3', fontsize=11, ha='center', color='#ea580c', fontweight='bold')
ax.text(4.4, 2, f'|Δy| = 2', fontsize=11, va='center', color='#ea580c', fontweight='bold')

# Legend with values
ax.text(0.02, 0.98, f'Euclidean: {euclidean:.2f}\nManhattan: {manhattan:.0f}',
        transform=ax.transAxes, fontsize=11, verticalalignment='top',
        bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))

ax.set_xlim(0, 5)
ax.set_ylim(0, 4)
ax.set_aspect('equal')
ax.set_xlabel('Dimension 1', fontsize=11)
ax.set_ylabel('Dimension 2', fontsize=11)
ax.grid(True, alpha=0.3)
ax.legend(loc='lower right')
plt.tight_layout()
plt.show()
```

```{python}
#| code-fold: false

"""
Manhattan Distance: City-Block Distance

Sum of absolute differences along each axis.
Range: 0 (identical) to infinity
"""

import numpy as np

def manhattan_distance(a, b):
    """Calculate Manhattan (L1) distance."""
    return np.sum(np.abs(a - b))

v1 = np.array([1.0, 2.0, 3.0])
v2 = np.array([4.0, 6.0, 3.0])

euclidean = np.linalg.norm(v1 - v2)
manhattan = manhattan_distance(v1, v2)

print("Comparing L1 vs L2 distance:")
print(f"  Euclidean (L2): {euclidean:.4f}")
print(f"  Manhattan (L1): {manhattan:.4f}")
```

**When to use Manhattan distance:**

- **Sparse data**: Less sensitive to outliers than Euclidean
- **Grid-like domains**: When movement is constrained to axes
- **Feature independence**: When dimensions represent independent attributes
- **Robust similarity**: Less affected by a single large difference

## Hamming Distance {#sec-hamming-distance}

Hamming distance counts the number of positions where values differ. For binary embeddings:

$$\text{hamming}(\mathbf{A}, \mathbf{B}) = \sum_{i=1}^{n} \mathbf{1}[A_i \neq B_i]$$

```{python}
#| label: fig-hamming-distance
#| fig-cap: "Hamming distance counts differing positions. Vectors A and B differ in 2 positions (red), giving Hamming distance = 2. Used for binary embeddings where comparison is a fast XOR operation."
#| echo: false

import matplotlib.pyplot as plt
import numpy as np

fig, ax = plt.subplots(figsize=(8, 3))

# Binary vectors
A = [1, 0, 1, 1, 0, 1, 0, 0]
B = [1, 0, 1, 0, 0, 1, 0, 1]

n = len(A)
y_A, y_B = 1.5, 0.5

# Draw boxes for each bit
for i in range(n):
    # Determine if bits match
    match = A[i] == B[i]
    color = '#22c55e' if match else '#ef4444'

    # Vector A
    rect_A = plt.Rectangle((i, y_A - 0.35), 0.9, 0.7,
                            facecolor='#dbeafe', edgecolor='#2563eb', lw=2)
    ax.add_patch(rect_A)
    ax.text(i + 0.45, y_A, str(A[i]), ha='center', va='center',
            fontsize=14, fontweight='bold', color='#2563eb')

    # Vector B
    rect_B = plt.Rectangle((i, y_B - 0.35), 0.9, 0.7,
                            facecolor='#dcfce7' if match else '#fee2e2',
                            edgecolor='#16a34a' if match else '#ef4444', lw=2)
    ax.add_patch(rect_B)
    ax.text(i + 0.45, y_B, str(B[i]), ha='center', va='center',
            fontsize=14, fontweight='bold', color='#16a34a' if match else '#ef4444')

    # Mark differences with X
    if not match:
        ax.text(i + 0.45, y_B - 0.65, '✗', ha='center', va='center',
                fontsize=16, color='#ef4444', fontweight='bold')

# Labels
ax.text(-0.7, y_A, 'A:', ha='right', va='center', fontsize=14, fontweight='bold', color='#2563eb')
ax.text(-0.7, y_B, 'B:', ha='right', va='center', fontsize=14, fontweight='bold', color='#16a34a')

# Calculate Hamming distance
hamming = sum(1 for a, b in zip(A, B) if a != b)
ax.text(n/2, -0.5, f'Hamming distance = {hamming} (positions 3 and 7 differ)',
        ha='center', fontsize=12, fontweight='bold')

ax.set_xlim(-1, n + 0.5)
ax.set_ylim(-1, 2.5)
ax.set_aspect('equal')
ax.axis('off')
plt.tight_layout()
plt.show()
```

```{python}
#| code-fold: false

"""
Hamming Distance: Bit-Level Comparison

Counts positions where values differ.
Essential for binary/quantized embeddings.
"""

import numpy as np

def hamming_distance(a, b):
    """Calculate Hamming distance for binary vectors."""
    return np.sum(a != b)

def hamming_similarity(a, b):
    """Normalized Hamming similarity (0 to 1)."""
    return 1 - hamming_distance(a, b) / len(a)

# Binary embeddings (e.g., from quantization)
b1 = np.array([1, 0, 1, 1, 0, 1, 0, 0])
b2 = np.array([1, 0, 1, 0, 0, 1, 0, 1])  # 2 bits different
b3 = np.array([0, 1, 0, 0, 1, 0, 1, 1])  # 8 bits different

print("Hamming distance (binary embeddings):")
print(f"  b1 ↔ b2 (similar): {hamming_distance(b1, b2)} bits differ, similarity: {hamming_similarity(b1, b2):.3f}")
print(f"  b1 ↔ b3 (opposite): {hamming_distance(b1, b3)} bits differ, similarity: {hamming_similarity(b1, b3):.3f}")
```

**When to use Hamming distance:**

- **Binary embeddings**: From binarization or locality-sensitive hashing
- **Quantized vectors**: After product quantization
- **Extreme scale**: Binary comparison is very fast (XOR + popcount)
- **Memory-constrained**: Binary vectors use 32x less storage than float32

See @sec-quantized-embeddings for more on binary and quantized embeddings.

## Jaccard Similarity {#sec-jaccard-similarity}

Jaccard similarity measures overlap between sets:

$$\text{jaccard}(\mathbf{A}, \mathbf{B}) = \frac{|A \cap B|}{|A \cup B|}$$

```{python}
#| label: fig-jaccard-similarity
#| fig-cap: "Jaccard similarity = intersection / union. Sets A and B share 3 elements (green overlap) out of 5 total unique elements, giving Jaccard = 3/5 = 0.60."
#| echo: false

import matplotlib.pyplot as plt
import numpy as np
from matplotlib.patches import Circle

fig, ax = plt.subplots(figsize=(7, 4))

# Create Venn diagram circles
circle_A = Circle((0.35, 0.5), 0.3, facecolor='#bfdbfe', edgecolor='#2563eb', lw=3, alpha=0.7)
circle_B = Circle((0.55, 0.5), 0.3, facecolor='#bbf7d0', edgecolor='#16a34a', lw=3, alpha=0.7)

ax.add_patch(circle_A)
ax.add_patch(circle_B)

# Add intersection coloring (approximate with a polygon)
theta = np.linspace(0, 2*np.pi, 100)
# Highlight intersection area conceptually
ax.text(0.45, 0.5, '3', fontsize=20, fontweight='bold', ha='center', va='center', color='#166534')

# Labels for sets
ax.text(0.2, 0.5, '1', fontsize=16, fontweight='bold', ha='center', va='center', color='#1e40af')
ax.text(0.7, 0.5, '1', fontsize=16, fontweight='bold', ha='center', va='center', color='#166534')

# Set labels
ax.text(0.2, 0.85, 'A', fontsize=18, fontweight='bold', ha='center', color='#2563eb')
ax.text(0.7, 0.85, 'B', fontsize=18, fontweight='bold', ha='center', color='#16a34a')

# Explanation
ax.text(0.45, 0.08, '|A ∩ B| = 3    |A ∪ B| = 5    Jaccard = 3/5 = 0.60',
        fontsize=12, ha='center', fontweight='bold',
        bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))

ax.set_xlim(0, 0.9)
ax.set_ylim(0, 1)
ax.set_aspect('equal')
ax.axis('off')
plt.tight_layout()
plt.show()
```

```{python}
#| code-fold: false

"""
Jaccard Similarity: Set Overlap

Measures intersection over union.
Range: 0 (no overlap) to 1 (identical sets)
"""

import numpy as np

def jaccard_similarity(a, b):
    """Calculate Jaccard similarity for binary/set vectors."""
    intersection = np.sum(np.logical_and(a, b))
    union = np.sum(np.logical_or(a, b))
    return intersection / union if union > 0 else 0

# Binary feature vectors (e.g., document has word or not)
doc1 = np.array([1, 1, 1, 0, 0, 1, 0, 0])  # Has words: 0, 1, 2, 5
doc2 = np.array([1, 1, 0, 0, 0, 1, 1, 0])  # Has words: 0, 1, 5, 6
doc3 = np.array([0, 0, 0, 1, 1, 0, 0, 1])  # Has words: 3, 4, 7

print("Jaccard similarity (set overlap):")
print(f"  doc1 ↔ doc2 (3 shared, 5 total): {jaccard_similarity(doc1, doc2):.3f}")
print(f"  doc1 ↔ doc3 (0 shared): {jaccard_similarity(doc1, doc3):.3f}")
```

**When to use Jaccard similarity:**

- **Sparse binary features**: Bag-of-words, tag sets
- **Set membership**: When presence/absence matters, not magnitude
- **Near-duplicate detection**: MinHash approximates Jaccard efficiently
- **Categorical data**: When features are one-hot encoded

## Metric Comparison Summary

| Metric | Range | Magnitude Sensitive | Best For | Vector DB Support |
|--------|-------|---------------------|----------|-------------------|
| **Cosine** | -1 to 1 | No | Text, normalized embeddings | Universal |
| **Euclidean (L2)** | 0 to ∞ | Yes | Images, low-dimensional | Universal |
| **Dot Product** | -∞ to ∞ | Yes | Recommendations, MIPS | Most |
| **Manhattan (L1)** | 0 to ∞ | Yes | Sparse data, outlier-robust | Some |
| **Hamming** | 0 to n | N/A (binary) | Binary embeddings | Some |
| **Jaccard** | 0 to 1 | N/A (sets) | Sparse sets, tags | Limited |

: Similarity and distance metrics comparison {.striped}

## Choosing the Right Metric

| Use Case | Embedding Type | Normalized? | Recommended Metric |
|----------|---------------|-------------|-------------------|
| Text (sentence transformers) | Dense | Yes | Cosine / Dot product |
| Image (CNN features) | Dense | No | Dot product |
| Recommendations (user-item) | Dense | No | Dot product |
| Binary hash codes | Binary | N/A | Hamming |
| Document tags | Sparse binary | N/A | Jaccard |

: Metric recommendations by use case {.striped}

### Decision Tree

```
Is your embedding binary?
├── Yes → Hamming distance
└── No → Is it sparse binary (sets/tags)?
    ├── Yes → Jaccard similarity
    └── No → Are vectors normalized?
        ├── Yes → Cosine similarity (fastest)
        └── No → Does magnitude encode importance?
            ├── Yes → Dot product or Euclidean
            └── No → Cosine similarity
```

## Impact on Vector Database Performance

Your metric choice affects index structure, query latency, and storage requirements:

| Metric | Index Type | HNSW Support | Storage | Query Overhead |
|--------|-----------|--------------|---------|----------------|
| **Cosine** | Normalize + L2 | ✓ Native | 1x | Normalize query |
| **Euclidean (L2)** | Native L2 | ✓ Native | 1x | None |
| **Dot Product** | MIPS or augmented L2 | ✓ With transform | 1x-1.01x | May need augmentation |
| **Hamming** | Binary index | Specialized | 0.03x (32x smaller) | Bitwise ops only |

: Vector database index compatibility by metric {.striped}

### Why This Matters

**Cosine vs. L2 equivalence**: For normalized vectors, cosine similarity and L2 distance produce identical rankings. Most databases exploit this—they normalize vectors once at insertion, then use fast L2 indexes:

```python
# These produce the same ranking for normalized vectors:
# cosine_sim(a, b) = 1 - (L2_dist(a, b)² / 2)
```

**Dot product challenges**: Unlike cosine and L2, dot product (MIPS—Maximum Inner Product Search) doesn't satisfy the triangle inequality. Some databases handle this by:

1. Appending a dimension to convert MIPS → L2 (slight storage overhead)
2. Using specialized MIPS indexes (less common)

**Binary embeddings**: Hamming distance enables 32x storage reduction (float32 → 1 bit per dimension) with specialized binary indexes. Ideal for large-scale deduplication where some quality loss is acceptable.

::: callout-tip
## Performance Tip

If using cosine similarity, **pre-normalize your embeddings** before insertion. This avoids redundant normalization at query time and lets you use faster L2 indexes directly.
:::

## Practical Considerations

### Normalization

```{python}
#| code-fold: false

"""
L2 Normalization: Making Cosine = Dot Product
"""

import numpy as np

def l2_normalize(vectors):
    """Normalize vectors to unit length."""
    norms = np.linalg.norm(vectors, axis=1, keepdims=True)
    return vectors / norms

# Original vectors
vectors = np.array([
    [3.0, 4.0],      # Magnitude 5
    [1.0, 1.0],      # Magnitude √2
    [10.0, 0.0],     # Magnitude 10
])

normalized = l2_normalize(vectors)

print("Before normalization:")
print(f"  Magnitudes: {np.linalg.norm(vectors, axis=1)}")

print("\nAfter L2 normalization:")
print(f"  Magnitudes: {np.linalg.norm(normalized, axis=1)}")

# Now dot product = cosine similarity
v1, v2 = normalized[0], normalized[1]
dot = np.dot(v1, v2)
cos = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))
print(f"\nFor normalized vectors: dot product = {dot:.4f}, cosine = {cos:.4f}")
```

### Metric Selection by Domain

| Domain | Typical Metric | Reason |
|--------|---------------|--------|
| **Semantic search** | Cosine | Text embeddings are normalized |
| **Image retrieval** | Cosine or L2 | Depends on model output |
| **Recommendations** | Dot product | Magnitude = confidence |
| **Face recognition** | Cosine | Normalized face embeddings |
| **Document dedup** | Jaccard or Cosine | Depending on representation |
| **Binary codes** | Hamming | Fast bitwise operations |

: Metric selection by application domain {.striped}

## Emerging and Future Metrics {#sec-emerging-metrics}

The standard metrics above handle most use cases, but research continues to develop specialized approaches for challenging scenarios.

### Hyperbolic Distance

For hierarchical data (taxonomies, org charts, knowledge graphs), Euclidean space is inefficient—it can't naturally represent tree structures. **Hyperbolic space** has negative curvature that matches hierarchical growth patterns:

```{python}
#| code-fold: false

"""
Hyperbolic Distance (Poincaré Ball Model)

Hyperbolic space naturally represents hierarchies.
Points near the center are "general"; points near the edge are "specific".
"""

import numpy as np

def poincare_distance(u, v):
    """
    Distance in the Poincaré ball model of hyperbolic space.

    As points approach the boundary (norm → 1), distances grow rapidly,
    creating "room" for exponentially many nodes at each level.
    """
    norm_u_sq = np.sum(u ** 2)
    norm_v_sq = np.sum(v ** 2)
    norm_diff_sq = np.sum((u - v) ** 2)

    # Hyperbolic distance formula
    return np.arccosh(
        1 + 2 * norm_diff_sq / ((1 - norm_u_sq) * (1 - norm_v_sq))
    )

# Example: Points in 2D Poincaré ball
center = np.array([0.0, 0.0])      # Root of hierarchy
mid_level = np.array([0.5, 0.0])   # Middle of tree
leaf = np.array([0.9, 0.0])        # Leaf node (near boundary)

print("Hyperbolic distances (Poincaré ball):")
print(f"  Center ↔ Mid-level: {poincare_distance(center, mid_level):.3f}")
print(f"  Mid-level ↔ Leaf: {poincare_distance(mid_level, leaf):.3f}")
print(f"  Center ↔ Leaf: {poincare_distance(center, leaf):.3f}")
```

**Use cases**: Product taxonomies, organizational hierarchies, knowledge graphs. Hyperbolic embeddings can represent hierarchies in 5-20 dimensions that would require 100-500 dimensions in Euclidean space.

### Learned Similarity Functions

Instead of choosing a fixed metric, **learn the similarity function** from your data:

```{python}
#| code-fold: false

"""
Learned Similarity: Let the model decide what "similar" means.

Approaches:
1. Mahalanobis distance (learns covariance structure)
2. Siamese networks (learn embedding + comparison jointly)
3. Cross-encoders (attend across both inputs)
"""

import numpy as np

class LearnedMahalanobis:
    """
    Mahalanobis distance with learned transformation matrix.

    Learns which dimensions matter and how they correlate.
    Equivalent to: d(x,y) = sqrt((x-y)^T M (x-y)) where M is learned.
    """

    def __init__(self, dim):
        # Initialize as identity (reduces to Euclidean)
        self.L = np.eye(dim)  # M = L^T L ensures positive semi-definite

    def distance(self, x, y):
        """Compute Mahalanobis distance with learned metric."""
        diff = x - y
        transformed = self.L @ diff
        return np.sqrt(np.sum(transformed ** 2))

    def fit(self, similar_pairs, dissimilar_pairs, learning_rate=0.01):
        """
        Learn metric from supervision (simplified).
        Real implementation uses gradient descent on triplet/contrastive loss.
        """
        # Pull similar pairs closer, push dissimilar pairs apart
        pass  # Actual training loop omitted for brevity

# Example usage
metric = LearnedMahalanobis(dim=128)
x = np.random.randn(128)
y = np.random.randn(128)
print(f"Learned Mahalanobis distance: {metric.distance(x, y):.3f}")
```

**When to use learned metrics:**
- Domain-specific similarity (what's "similar" in your domain isn't captured by cosine)
- Few-shot learning (learn from limited examples)
- When you have supervision signal (click data, ratings, labels)

### Approximate Metrics at Scale

At billion-scale, even computing exact similarity becomes expensive. **Approximate metrics** trade accuracy for speed:

```{python}
#| code-fold: false

"""
Approximate Similarity for Extreme Scale

Techniques:
1. Locality-Sensitive Hashing (LSH): Hash similar items to same bucket
2. Product Quantization (PQ): Compress vectors, approximate distance
3. Random Projections: Preserve relative distances approximately
"""

import numpy as np

def random_projection_similarity(a, b, n_projections=100, seed=42):
    """
    Approximate cosine similarity using random projections.

    Project to random hyperplanes, count sign agreements.
    More agreements = more similar (probabilistically).
    """
    np.random.seed(seed)
    dim = len(a)

    # Generate random projection vectors
    projections = np.random.randn(n_projections, dim)

    # Project both vectors
    proj_a = np.sign(projections @ a)
    proj_b = np.sign(projections @ b)

    # Count agreements (same sign = similar direction)
    agreement_rate = np.mean(proj_a == proj_b)

    # Convert to approximate cosine similarity
    # (1 - 2*theta/pi) where theta is angle
    approx_cosine = np.cos(np.pi * (1 - agreement_rate))

    return approx_cosine

# Compare exact vs approximate
a = np.random.randn(768)
b = a + np.random.randn(768) * 0.5  # Similar vector

exact_cosine = np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))
approx_cosine = random_projection_similarity(a, b)

print("Exact vs Approximate similarity:")
print(f"  Exact cosine: {exact_cosine:.4f}")
print(f"  Approx (100 projections): {approx_cosine:.4f}")
print(f"  Error: {abs(exact_cosine - approx_cosine):.4f}")
```

**Trade-offs:**
- LSH: O(1) lookup but requires tuning hash functions
- PQ: 10-100x compression, ~5% recall loss typical
- Random projections: Simple, parallelizable, theoretical guarantees

### Task-Adaptive Metrics

The best metric depends on your task. **Metric learning** optimizes the similarity function end-to-end:

| Approach | How It Works | Best For |
|----------|--------------|----------|
| **Triplet loss** | Learn: d(anchor, positive) < d(anchor, negative) | Face recognition, retrieval |
| **Contrastive loss** | Pull positives together, push negatives apart | Self-supervised learning |
| **Cross-encoder** | Jointly encode both inputs, predict similarity | Reranking, high-precision |
| **Late interaction** | Multiple vectors per item, aggregate similarities | Fine-grained matching |

: Task-adaptive metric learning approaches {.striped}

For detailed coverage of these training approaches, see @sec-contrastive-learning and @sec-siamese-networks.

## Key Takeaways

- **Cosine similarity** is the default for most embedding applications—it ignores magnitude and works well in high dimensions

- **Euclidean distance** is magnitude-sensitive and works best in lower dimensions; suffers from curse of dimensionality at 768+ dims

- **Dot product** rewards both alignment and magnitude—use when larger embeddings should match more strongly

- **Hamming distance** enables ultra-fast search on binary embeddings with 32x storage savings

- **Metric choice affects indexing**: Most vector databases optimize for L2/cosine; other metrics may require transformation

- **Pre-normalize for cosine**: If using cosine similarity, normalize vectors before insertion to avoid redundant computation

- **Emerging approaches** like hyperbolic distance, learned metrics, and approximate similarity address specialized needs—hierarchical data, domain-specific similarity, and extreme scale

## Looking Ahead

With similarity metrics understood, @sec-vector-database-fundamentals covers how vector databases use these metrics to build efficient indexes at scale. For binary and quantized embeddings that use Hamming distance, see @sec-quantized-embeddings in the advanced patterns chapter.

## Further Reading

- Aggarwal, C. C., Hinneburg, A., & Keim, D. A. (2001). "On the Surprising Behavior of Distance Metrics in High Dimensional Space." *ICDT*
- Johnson, J., Douze, M., & Jégou, H. (2019). "Billion-scale similarity search with GPUs." *IEEE Transactions on Big Data*
- Wang, J., et al. (2018). "A Survey on Learning to Hash." *IEEE TPAMI*
